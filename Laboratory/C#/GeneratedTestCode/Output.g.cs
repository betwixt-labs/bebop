//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           0.0.1-20210423-1500
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//
// This source code was auto-generated by bebopc, Version=0.0.1-20210423-1500.
//
namespace Bebop.Codegen {
  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Int32S : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Int32S> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public int[] A { get; set; }

    /// <summary>
    /// </summary>
    public Int32S() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="a">
    /// </param>
    public Int32S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] int[] a) => (A) = (a);
    public Int32S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Int32S original) => (A) = (original.A);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out int[] a) => (a) = (A);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 4;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 4;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Int32S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Int32S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int32S Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int32S Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int32S Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int32S Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int32S Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Int32S record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      {
        var length0 = unchecked((uint)record.A.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          writer.WriteInt32(record.A[i0]);
        }
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Int32S __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      int[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new int[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          int x0;
          x0 = reader.ReadInt32();
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.Int32S {
        A = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Int32S other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (A is null ? other.A is null : other.A is not null && global::System.Linq.Enumerable.SequenceEqual(A, other.A));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Int32S baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= A.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Int32S left, global::Bebop.Codegen.Int32S right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Int32S left, global::Bebop.Codegen.Int32S  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Uint32S : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Uint32S> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public uint[] A { get; set; }

    /// <summary>
    /// </summary>
    public Uint32S() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="a">
    /// </param>
    public Uint32S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] uint[] a) => (A) = (a);
    public Uint32S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Uint32S original) => (A) = (original.A);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out uint[] a) => (a) = (A);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 4;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 4;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Uint32S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Uint32S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint32S Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint32S Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint32S Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint32S Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint32S Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Uint32S record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      {
        var length0 = unchecked((uint)record.A.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          writer.WriteUInt32(record.A[i0]);
        }
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Uint32S __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      uint[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new uint[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          uint x0;
          x0 = reader.ReadUInt32();
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.Uint32S {
        A = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Uint32S other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (A is null ? other.A is null : other.A is not null && global::System.Linq.Enumerable.SequenceEqual(A, other.A));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Uint32S baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= A.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Uint32S left, global::Bebop.Codegen.Uint32S right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Uint32S left, global::Bebop.Codegen.Uint32S  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Float32S : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Float32S> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public float[] A { get; set; }

    /// <summary>
    /// </summary>
    public Float32S() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="a">
    /// </param>
    public Float32S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] float[] a) => (A) = (a);
    public Float32S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Float32S original) => (A) = (original.A);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out float[] a) => (a) = (A);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 4;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 4;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Float32S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Float32S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float32S Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float32S Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float32S Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float32S Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float32S Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Float32S record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteFloat32S(record.A);
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Float32S __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      float[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new float[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          float x0;
          x0 = reader.ReadFloat32();
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.Float32S {
        A = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Float32S other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (A is null ? other.A is null : other.A is not null && global::System.Linq.Enumerable.SequenceEqual(A, other.A));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Float32S baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= A.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Float32S left, global::Bebop.Codegen.Float32S right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Float32S left, global::Bebop.Codegen.Float32S  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Int64S : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Int64S> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public long[] A { get; set; }

    /// <summary>
    /// </summary>
    public Int64S() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="a">
    /// </param>
    public Int64S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] long[] a) => (A) = (a);
    public Int64S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Int64S original) => (A) = (original.A);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out long[] a) => (a) = (A);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 8;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 8;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Int64S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Int64S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int64S Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int64S Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int64S Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int64S Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Int64S Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Int64S record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      {
        var length0 = unchecked((uint)record.A.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          writer.WriteInt64(record.A[i0]);
        }
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Int64S __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      long[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new long[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          long x0;
          x0 = reader.ReadInt64();
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.Int64S {
        A = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Int64S other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (A is null ? other.A is null : other.A is not null && global::System.Linq.Enumerable.SequenceEqual(A, other.A));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Int64S baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= A.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Int64S left, global::Bebop.Codegen.Int64S right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Int64S left, global::Bebop.Codegen.Int64S  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Uint64S : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Uint64S> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public ulong[] A { get; set; }

    /// <summary>
    /// </summary>
    public Uint64S() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="a">
    /// </param>
    public Uint64S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] ulong[] a) => (A) = (a);
    public Uint64S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Uint64S original) => (A) = (original.A);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out ulong[] a) => (a) = (A);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 8;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 8;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Uint64S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Uint64S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint64S Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint64S Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint64S Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint64S Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Uint64S Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Uint64S record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      {
        var length0 = unchecked((uint)record.A.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          writer.WriteUInt64(record.A[i0]);
        }
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Uint64S __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      ulong[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new ulong[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          ulong x0;
          x0 = reader.ReadUInt64();
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.Uint64S {
        A = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Uint64S other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (A is null ? other.A is null : other.A is not null && global::System.Linq.Enumerable.SequenceEqual(A, other.A));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Uint64S baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= A.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Uint64S left, global::Bebop.Codegen.Uint64S right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Uint64S left, global::Bebop.Codegen.Uint64S  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Float64S : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Float64S> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public double[] A { get; set; }

    /// <summary>
    /// </summary>
    public Float64S() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="a">
    /// </param>
    public Float64S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] double[] a) => (A) = (a);
    public Float64S([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Float64S original) => (A) = (original.A);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out double[] a) => (a) = (A);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 8;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + A.Length * 8;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Float64S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Float64S record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float64S Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float64S Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float64S Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float64S Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Float64S Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Float64S record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteFloat64S(record.A);
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Float64S __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      double[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new double[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          double x0;
          x0 = reader.ReadFloat64();
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.Float64S {
        A = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Float64S other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (A is null ? other.A is null : other.A is not null && global::System.Linq.Enumerable.SequenceEqual(A, other.A));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Float64S baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= A.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Float64S left, global::Bebop.Codegen.Float64S right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Float64S left, global::Bebop.Codegen.Float64S  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Enum)]
  public enum VideoCodec : uint {
    H264 = 0,
    H265 = 1
  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class VideoData : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<VideoData> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public double Time { get; set; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public uint Width { get; set; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public uint Height { get; set; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::System.Collections.Immutable.ImmutableArray<byte> Fragment { get; set; }

    /// <summary>
    /// </summary>
    public VideoData() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="time">
    /// </param>
    /// <param name="width">
    /// </param>
    /// <param name="height">
    /// </param>
    /// <param name="fragment">
    /// </param>
    public VideoData([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] double time, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] uint width, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] uint height, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::System.Collections.Immutable.ImmutableArray<byte> fragment) => (Time, Width, Height, Fragment) = (time, width, height, fragment);
    public VideoData([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] VideoData original) => (Time, Width, Height, Fragment) = (original.Time, original.Width, original.Height, original.Fragment);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out double time, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out uint width, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out uint height, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::System.Collections.Immutable.ImmutableArray<byte> fragment) => (time, width, height, fragment) = (Time, Width, Height, Fragment);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(double);
      byteCount += sizeof(uint);
      byteCount += sizeof(uint);
      byteCount += sizeof(uint) + Fragment.Length * 1;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(double);
      byteCount += sizeof(uint);
      byteCount += sizeof(uint);
      byteCount += sizeof(uint) + Fragment.Length * 1;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.VideoData record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.VideoData record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.VideoData Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.VideoData Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.VideoData Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.VideoData Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.VideoData Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.VideoData record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteFloat64(record.Time);
      writer.WriteUInt32(record.Width);
      writer.WriteUInt32(record.Height);
      writer.WriteBytes(record.Fragment);
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.VideoData __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      double field0;
      field0 = reader.ReadFloat64();
      uint field1;
      field1 = reader.ReadUInt32();
      uint field2;
      field2 = reader.ReadUInt32();
      global::System.Collections.Immutable.ImmutableArray<byte> field3;
      field3 = reader.ReadBytes();
      return new global::Bebop.Codegen.VideoData {
        Time = field0,
        Width = field1,
        Height = field2,
        Fragment = field3,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.VideoData other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Time == other.Time && Width == other.Width && Height == other.Height && (Fragment == null ? other.Fragment == null : other.Fragment != null && global::System.Linq.Enumerable.SequenceEqual(Fragment, other.Fragment));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.VideoData baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Time.GetHashCode();
      hash ^= Width.GetHashCode();
      hash ^= Height.GetHashCode();
      hash ^= Fragment.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.VideoData left, global::Bebop.Codegen.VideoData right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.VideoData left, global::Bebop.Codegen.VideoData  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class MediaMessage : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<MediaMessage> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.VideoCodec? Codec { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.VideoData? Data { get; set; }

    /// <summary>
    /// </summary>
    public MediaMessage() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="codec">
    /// </param>
    /// <param name="data">
    /// </param>
    public MediaMessage([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.VideoCodec? codec, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.VideoData? data) => (Codec, Data) = (codec, data);
    public MediaMessage([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] MediaMessage? original) => (Codec, Data) = (original?.Codec, original?.Data);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.VideoCodec? codec, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.VideoData? data) => (codec, data) = (Codec, Data);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Codec is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint);
      }
      if (Data is not null) {
        byteCount += sizeof(byte);
        byteCount += Data.MaxByteCount;
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Codec is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint);
      }
      if (Data is not null) {
        byteCount += sizeof(byte);
        byteCount += Data.ByteCount;
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.MediaMessage record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.MediaMessage record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.MediaMessage Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.MediaMessage Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.MediaMessage Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.MediaMessage Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.MediaMessage Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.MediaMessage record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Codec is not null) {
        writer.WriteByte(1);
        writer.WriteEnum<global::Bebop.Codegen.VideoCodec>(record.Codec.Value);
      }

      if (record.Data is not null) {
        writer.WriteByte(2);
        global::Bebop.Codegen.VideoData.__EncodeInto(record.Data, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.MediaMessage __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.MediaMessage();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Codec = reader.ReadEnum<global::Bebop.Codegen.VideoCodec>();
            break;
          case 2:
            record.Data = global::Bebop.Codegen.VideoData.__DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.MediaMessage other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Codec == other.Codec && Data == other.Data;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.MediaMessage baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Codec is not null) hash ^= Codec.Value.GetHashCode();
      if (Data is not null) hash ^= Data.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.MediaMessage left, global::Bebop.Codegen.MediaMessage right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.MediaMessage left, global::Bebop.Codegen.MediaMessage  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class SkipTestOld : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<SkipTestOld> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? X { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? Y { get; set; }

    /// <summary>
    /// </summary>
    public SkipTestOld() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="x">
    /// </param>
    /// <param name="y">
    /// </param>
    public SkipTestOld([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? x, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? y) => (X, Y) = (x, y);
    public SkipTestOld([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] SkipTestOld? original) => (X, Y) = (original?.X, original?.Y);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? x, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? y) => (x, y) = (X, Y);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (X is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      if (Y is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (X is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      if (Y is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.SkipTestOld record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.SkipTestOld record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOld Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOld Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOld Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOld Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOld Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.SkipTestOld record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.X is not null) {
        writer.WriteByte(1);
        writer.WriteInt32(record.X.Value);
      }

      if (record.Y is not null) {
        writer.WriteByte(2);
        writer.WriteInt32(record.Y.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.SkipTestOld __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.SkipTestOld();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.X = reader.ReadInt32();
            break;
          case 2:
            record.Y = reader.ReadInt32();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.SkipTestOld other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X && Y == other.Y;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.SkipTestOld baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (X is not null) hash ^= X.Value.GetHashCode();
      if (Y is not null) hash ^= Y.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.SkipTestOld left, global::Bebop.Codegen.SkipTestOld right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.SkipTestOld left, global::Bebop.Codegen.SkipTestOld  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class SkipTestNew : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<SkipTestNew> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? X { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? Y { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? Z { get; set; }

    /// <summary>
    /// </summary>
    public SkipTestNew() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="x">
    /// </param>
    /// <param name="y">
    /// </param>
    /// <param name="z">
    /// </param>
    public SkipTestNew([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? x, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? y, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? z) => (X, Y, Z) = (x, y, z);
    public SkipTestNew([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] SkipTestNew? original) => (X, Y, Z) = (original?.X, original?.Y, original?.Z);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? x, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? y, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? z) => (x, y, z) = (X, Y, Z);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (X is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      if (Y is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      if (Z is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (X is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      if (Y is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      if (Z is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.SkipTestNew record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.SkipTestNew record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNew Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNew Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNew Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNew Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNew Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.SkipTestNew record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.X is not null) {
        writer.WriteByte(1);
        writer.WriteInt32(record.X.Value);
      }

      if (record.Y is not null) {
        writer.WriteByte(2);
        writer.WriteInt32(record.Y.Value);
      }

      if (record.Z is not null) {
        writer.WriteByte(3);
        writer.WriteInt32(record.Z.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.SkipTestNew __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.SkipTestNew();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.X = reader.ReadInt32();
            break;
          case 2:
            record.Y = reader.ReadInt32();
            break;
          case 3:
            record.Z = reader.ReadInt32();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.SkipTestNew other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X && Y == other.Y && Z == other.Z;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.SkipTestNew baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (X is not null) hash ^= X.Value.GetHashCode();
      if (Y is not null) hash ^= Y.Value.GetHashCode();
      if (Z is not null) hash ^= Z.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.SkipTestNew left, global::Bebop.Codegen.SkipTestNew right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.SkipTestNew left, global::Bebop.Codegen.SkipTestNew  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class SkipTestOldContainer : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<SkipTestOldContainer> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.SkipTestOld? S { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? After { get; set; }

    /// <summary>
    /// </summary>
    public SkipTestOldContainer() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="s">
    /// </param>
    /// <param name="after">
    /// </param>
    public SkipTestOldContainer([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.SkipTestOld? s, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? after) => (S, After) = (s, after);
    public SkipTestOldContainer([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] SkipTestOldContainer? original) => (S, After) = (original?.S, original?.After);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.SkipTestOld? s, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? after) => (s, after) = (S, After);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (S is not null) {
        byteCount += sizeof(byte);
        byteCount += S.MaxByteCount;
      }
      if (After is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (S is not null) {
        byteCount += sizeof(byte);
        byteCount += S.ByteCount;
      }
      if (After is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.SkipTestOldContainer record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.SkipTestOldContainer record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOldContainer Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOldContainer Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOldContainer Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOldContainer Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestOldContainer Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.SkipTestOldContainer record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.S is not null) {
        writer.WriteByte(1);
        global::Bebop.Codegen.SkipTestOld.__EncodeInto(record.S, ref writer);
      }

      if (record.After is not null) {
        writer.WriteByte(2);
        writer.WriteInt32(record.After.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.SkipTestOldContainer __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.SkipTestOldContainer();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.S = global::Bebop.Codegen.SkipTestOld.__DecodeFrom(ref reader);
            break;
          case 2:
            record.After = reader.ReadInt32();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.SkipTestOldContainer other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return S == other.S && After == other.After;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.SkipTestOldContainer baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (S is not null) hash ^= S.GetHashCode();
      if (After is not null) hash ^= After.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.SkipTestOldContainer left, global::Bebop.Codegen.SkipTestOldContainer right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.SkipTestOldContainer left, global::Bebop.Codegen.SkipTestOldContainer  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class SkipTestNewContainer : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<SkipTestNewContainer> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.SkipTestNew? S { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public int? After { get; set; }

    /// <summary>
    /// </summary>
    public SkipTestNewContainer() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="s">
    /// </param>
    /// <param name="after">
    /// </param>
    public SkipTestNewContainer([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.SkipTestNew? s, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] int? after) => (S, After) = (s, after);
    public SkipTestNewContainer([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] SkipTestNewContainer? original) => (S, After) = (original?.S, original?.After);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.SkipTestNew? s, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out int? after) => (s, after) = (S, After);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (S is not null) {
        byteCount += sizeof(byte);
        byteCount += S.MaxByteCount;
      }
      if (After is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (S is not null) {
        byteCount += sizeof(byte);
        byteCount += S.ByteCount;
      }
      if (After is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(int);
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.SkipTestNewContainer record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.SkipTestNewContainer record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNewContainer Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNewContainer Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNewContainer Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNewContainer Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.SkipTestNewContainer Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.SkipTestNewContainer record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.S is not null) {
        writer.WriteByte(1);
        global::Bebop.Codegen.SkipTestNew.__EncodeInto(record.S, ref writer);
      }

      if (record.After is not null) {
        writer.WriteByte(2);
        writer.WriteInt32(record.After.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.SkipTestNewContainer __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.SkipTestNewContainer();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.S = global::Bebop.Codegen.SkipTestNew.__DecodeFrom(ref reader);
            break;
          case 2:
            record.After = reader.ReadInt32();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.SkipTestNewContainer other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return S == other.S && After == other.After;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.SkipTestNewContainer baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (S is not null) hash ^= S.GetHashCode();
      if (After is not null) hash ^= After.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.SkipTestNewContainer left, global::Bebop.Codegen.SkipTestNewContainer right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.SkipTestNewContainer left, global::Bebop.Codegen.SkipTestNewContainer  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Enum)]
  public enum Instrument : uint {
    Sax = 0,
    Trumpet = 1,
    Clarinet = 2
  }

  /// <summary>
  /// <para>test</para>
  /// </summary>
  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct, true)]
  public partial class Musician : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Musician> {
    public const uint OpCode = 0x5A5A414A;
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    /// <summary>
    /// <para>a name</para>
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Name { get; init; }
    /// <summary>
    /// <para>an instrument</para>
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::Bebop.Codegen.Instrument Plays { get; init; }

    /// <summary>
    /// <para>test</para>
    /// </summary>
    public Musician() : base() { }
    /// <summary>
    /// <para>test</para>
    /// </summary>
    /// <param name="name">
    /// <para>a name</para>
    /// </param>
    /// <param name="plays">
    /// <para>an instrument</para>
    /// </param>
    public Musician([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string name, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::Bebop.Codegen.Instrument plays) => (Name, Plays) = (name, plays);
    public Musician([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Musician original) => (Name, Plays) = (original.Name, original.Plays);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string name, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::Bebop.Codegen.Instrument plays) => (name, plays) = (Name, Plays);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Name.Length);
      byteCount += sizeof(uint);
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Name);
      byteCount += sizeof(uint);
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Musician record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Musician record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Musician record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteString(record.Name);
      writer.WriteEnum<global::Bebop.Codegen.Instrument>(record.Plays);
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Musician __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      global::Bebop.Codegen.Instrument field1;
      field1 = reader.ReadEnum<global::Bebop.Codegen.Instrument>();
      return new global::Bebop.Codegen.Musician {
        Name = field0,
        Plays = field1,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Musician other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Name == other.Name && Plays == other.Plays;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Musician baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Name.GetHashCode();
      hash ^= Plays.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Musician left, global::Bebop.Codegen.Musician right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Musician left, global::Bebop.Codegen.Musician  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class Song : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Song> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public string? Title { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public ushort? Year { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.Musician[]? Performers { get; set; }

    /// <summary>
    /// </summary>
    public Song() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="title">
    /// </param>
    /// <param name="year">
    /// </param>
    /// <param name="performers">
    /// </param>
    public Song([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] string? title, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] ushort? year, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.Musician[]? performers) => (Title, Year, Performers) = (title, year, performers);
    public Song([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] Song? original) => (Title, Year, Performers) = (original?.Title, original?.Year, original?.Performers);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out string? title, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out ushort? year, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.Musician[]? performers) => (title, year, performers) = (Title, Year, Performers);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Title is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Title.Length);
      }
      if (Year is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(ushort);
      }
      if (Performers is not null) {
        byteCount += sizeof(byte);
        {
          var length0 = unchecked((uint)Performers.Length);
          byteCount += sizeof(uint);
          for (var i0 = 0; i0 < length0; i0++) {
            byteCount += Performers[i0].MaxByteCount;
          }
        }
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Title is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Title);
      }
      if (Year is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(ushort);
      }
      if (Performers is not null) {
        byteCount += sizeof(byte);
        {
          var length0 = unchecked((uint)Performers.Length);
          byteCount += sizeof(uint);
          for (var i0 = 0; i0 < length0; i0++) {
            byteCount += Performers[i0].ByteCount;
          }
        }
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Song record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Song record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Song record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Title is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.Title);
      }

      if (record.Year is not null) {
        writer.WriteByte(2);
        writer.WriteUInt16(record.Year.Value);
      }

      if (record.Performers is not null) {
        writer.WriteByte(3);
        {
          var length0 = unchecked((uint)record.Performers.Length);
          writer.WriteUInt32(length0);
          for (var i0 = 0; i0 < length0; i0++) {
            global::Bebop.Codegen.Musician.__EncodeInto(record.Performers[i0], ref writer);
          }
        }
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Song __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.Song();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Title = reader.ReadString();
            break;
          case 2:
            record.Year = reader.ReadUInt16();
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Performers = new global::Bebop.Codegen.Musician[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                global::Bebop.Codegen.Musician x0;
                x0 = global::Bebop.Codegen.Musician.__DecodeFrom(ref reader);
                record.Performers[i0] = x0;
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Song other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Title == other.Title && Year == other.Year && (Performers is null ? other.Performers is null : other.Performers is not null && global::System.Linq.Enumerable.SequenceEqual(Performers, other.Performers));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Song baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Title is not null) hash ^= Title.GetHashCode();
      if (Year is not null) hash ^= Year.Value.GetHashCode();
      if (Performers is not null) hash ^= Performers.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Song left, global::Bebop.Codegen.Song right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Song left, global::Bebop.Codegen.Song  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210423-1500")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Library : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Library> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> Songs { get; set; }

    /// <summary>
    /// </summary>
    public Library() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="songs">
    /// </param>
    public Library([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> songs) => (Songs) = (songs);
    public Library([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Library original) => (Songs) = (original.Songs);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> songs) => (songs) = (Songs);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint);
      foreach (var kv0 in Songs) {
        byteCount += 16;
        byteCount += kv0.Value.MaxByteCount;
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint);
      foreach (var kv0 in Songs) {
        byteCount += 16;
        byteCount += kv0.Value.ByteCount;
      }
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Library record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Library record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Library record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteUInt32(unchecked((uint)record.Songs.Count));
      foreach (var kv0 in record.Songs) {
        writer.WriteGuid(kv0.Key);
        global::Bebop.Codegen.Song.__EncodeInto(kv0.Value, ref writer);
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Library __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          global::System.Guid k0;
          global::Bebop.Codegen.Song v0;
          k0 = reader.ReadGuid();
          v0 = global::Bebop.Codegen.Song.__DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new global::Bebop.Codegen.Library {
        Songs = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Library other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Songs is null ? other.Songs is null : other.Songs is not null && global::System.Linq.Enumerable.SequenceEqual(Songs, other.Songs));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Library baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Songs.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Library left, global::Bebop.Codegen.Library right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Library left, global::Bebop.Codegen.Library  right) => !Equals(left, right);
    #endregion

  }

}
