// unset

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Core.Meta;
using Core.Meta.Attributes;
using Core.Meta.Extensions;

namespace Core.Generators.Rust
{
    enum OwnershipType
    {
        // name used when borrowed, E.g. `SliceWrapper<'raw, u8>` or `&'raw str`.
        Borrowed,

        // name used when owned, E.g. `Vec<u8>` or `String`.
        Owned,

        // name used when declared as a global constant, E.g. `&[u8]` or `&str`.
        Constant
    }

    enum CodeRegion
    {
        // The main code region, home to constants and the main (borrowed of fixed-sized) type definitions
        Main,

        // The owned code region, home to owned type definitions (no lifetimes) and re-exports of main which conform.
        Owned
    }

    public class RustGenerator : BaseGenerator
    {
        #region state

        const int _tab = 4;

        private static readonly ImmutableHashSet<string> _reservedWords = new[]
        {
            "Self", "abstract", "as", "become", "box", "break", "const", "continue", "crate", "do", "else", "enum",
            "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop", "macro", "match", "mod",
            "move", "mut", "override", "priv", "pub", "ref", "return", "self", "static", "struct", "super", "trait",
            "true", "try", "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield",
        }.ToImmutableHashSet();

        // TODO: should we get this list from the SchemaRepo or something to prevent sync issues?
        private static readonly ImmutableHashSet<string> _rpcDefinitionsToIgnore =
            new[]
            {
                "RpcDatagram", "RpcRequestHeader", "RpcResponseHeader", "RpcServiceNameReturn", "RpcServiceNameArgs"
            }.ToImmutableHashSet();

        private Dictionary<string, bool> _needsLifetime = new Dictionary<string, bool>();

        #endregion

        #region entrypoints

        public RustGenerator(BebopSchema schema) : base(schema) { }

        public override string Compile(Version? languageVersion, bool writeGeneratedNotice = true)
        {
            // the main scope which is where we write the const definitions and the borrowed types (as these are the
            // primary way to use bebop in Rust)
            var mainBuilder = new IndentedStringBuilder();
            // thw owned space which goes after the borrowed space in its own module, it should refer to `super` to
            // access the main scope.
            var ownedBuilder = new IndentedStringBuilder();

            if (writeGeneratedNotice)
            {
                mainBuilder
                    .AppendLine(GeneratorUtils.GetMarkdownAutoGeneratedNotice())
                    .AppendLine();
            }

            if (!string.IsNullOrWhiteSpace(Schema.Namespace))
            {
                mainBuilder.AppendLine($"#![cfg(feature = \"{MakeFeatureIdent(Schema.Namespace)}\")]");
            }

            WriteStandardImportsForModule(mainBuilder);
            WriteStandardImportsForModule(ownedBuilder);

            var hasServiceDefinition = Schema.Definitions.Values.Any(d => d is ServiceDefinition);

            foreach (var definition in Schema.Definitions.Values)
            {
                if (hasServiceDefinition && _rpcDefinitionsToIgnore.Contains(definition.Name))
                {
                    // We don't want to generate the RPC types for Rust because we need them in the Runtime due to
                    // the static nature of rust, so just ignore them.
                    continue;
                }

                switch (definition)
                {
                    case ConstDefinition cd:
                        WriteConstDefinition(mainBuilder, cd, CodeRegion.Main);
                        WriteConstDefinition(ownedBuilder, cd, CodeRegion.Owned);
                        mainBuilder.AppendLine();
                        ownedBuilder.AppendLine();
                        break;
                    case EnumDefinition ed:
                        WriteEnumDefinition(mainBuilder, ed, CodeRegion.Main);
                        WriteEnumDefinition(ownedBuilder, ed, CodeRegion.Owned);
                        mainBuilder.AppendLine();
                        ownedBuilder.AppendLine();
                        break;
                    case MessageDefinition md:
                        if (md.Parent is UnionDefinition) continue;
                        WriteMessageDefinition(mainBuilder, md, CodeRegion.Main);
                        WriteMessageDefinition(ownedBuilder, md, CodeRegion.Owned);
                        mainBuilder.AppendLine();
                        ownedBuilder.AppendLine();
                        break;
                    case StructDefinition sd:
                        if (sd.Parent is UnionDefinition) continue;
                        WriteStructDefinition(mainBuilder, sd, CodeRegion.Main);
                        WriteStructDefinition(ownedBuilder, sd, CodeRegion.Owned);
                        mainBuilder.AppendLine();
                        ownedBuilder.AppendLine();
                        break;
                    case UnionDefinition ud:
                        WriteUnionDefinition(mainBuilder, ud, CodeRegion.Main);
                        WriteUnionDefinition(ownedBuilder, ud, CodeRegion.Owned);
                        mainBuilder.AppendLine();
                        ownedBuilder.AppendLine();
                        break;
                    case ServiceDefinition sd:
                        // for now we only support the owned datagrams so might as well put it where it can reference
                        // them correctly.
                        WriteServiceDefinition(ownedBuilder, sd);
                        ownedBuilder.AppendLine();
                        break;
                    default:
                        throw new InvalidOperationException($"unsupported definition {definition.GetType()}");
                }
            }

            mainBuilder
                .AppendLine(string.IsNullOrWhiteSpace(Schema.Namespace)
                    ? "#[cfg(feature = \"bebop-owned-all\")]"
                    : $"#[cfg(any(feature = \"bebop-owned-all\", feature = \"{MakeFeatureIdent(Schema.Namespace)}-owned\"))]")
                .CodeBlock("pub mod owned", _tab, () =>
                {
                    mainBuilder.Append(ownedBuilder.ToString());
                });

            return mainBuilder.ToString();
        }

        public override void WriteAuxiliaryFiles(string outputPath)
        {
            // Nothing to do because the runtime is a cargo package.
        }

        #endregion

        #region definition_writers

        private void WriteStandardImportsForModule(IndentedStringBuilder bldr) =>
            bldr.AppendLine("#![allow(warnings)]")
                .AppendLine()
                .AppendLine("use ::std::io::Write as _;")
                .AppendLine("use ::core::convert::TryInto as _;") // we can remove this for Rust 2021
                .AppendLine("use ::bebop::FixedSized as _;")
                .AppendLine("use ::bebop::Record as _;")
                .AppendLine();

        private void WriteConstDefinition(IndentedStringBuilder builder, ConstDefinition d, CodeRegion region)
        {
            var ident = MakeConstIdent(d.Name);
            switch (region)
            {
                case CodeRegion.Main:
                    WriteDocumentation(builder, d.Documentation);
                    builder.AppendLine(
                        $"pub const {ident}: {TypeName(d.Value.Type, OwnershipType.Constant)} = {EmitLiteral(d.Value)};");
                    break;
                case CodeRegion.Owned:
                    builder.AppendLine($"pub use super::{ident};");
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(region), region, null);
            }
        }

        private void WriteEnumDefinition(IndentedStringBuilder builder, EnumDefinition d, CodeRegion region)
        {
            // main definition
            var name = MakeDefIdent(d.Name);
            var type = TypeName(d.ScalarType, OwnershipType.Constant);

            if (region == CodeRegion.Owned)
            {
                builder.AppendLine($"pub use super::{name};");
                return;
            }

            WriteDocumentation(builder, d.Documentation);

            if (d.IsBitFlags)
            {
                builder
                    .CodeBlock("::bebop::bitflags!", _tab, () =>
                    {
                        builder
                            .AppendLine("#[repr(transparent)]")
                            .CodeBlock($"pub struct {name}: {type}", _tab, () =>
                            {
                                foreach (var m in d.Members)
                                {
                                    WriteDocumentation(builder, m.Documentation);
                                    WriteDeprecation(builder, m.DeprecatedAttribute);
                                    builder.AppendLine($"const {MakeConstIdent(m.Name)} = {m.ConstantValue};");
                                }
                            });
                    }).AppendLine();
            }
            else
            {
                builder
                    .AppendLine($"#[repr({type})]")
                    .AppendLine("#[derive(Copy, Clone, Debug, Eq, PartialEq)]")
                    .CodeBlock($"pub enum {name}", _tab, () =>
                    {
                        foreach (var m in d.Members)
                        {
                            WriteDocumentation(builder, m.Documentation);
                            WriteDeprecation(builder, m.DeprecatedAttribute);
                            builder.AppendLine($"{MakeEnumVariantIdent(m.Name)} = {m.ConstantValue},");
                        }
                    }).AppendLine();

                // conversion from int
                builder.CodeBlock($"impl ::core::convert::TryFrom<{type}> for {name}", _tab, () =>
                {
                    builder.AppendLine("type Error = ::bebop::DeserializeError;")
                        .AppendLine()
                        .CodeBlock($"fn try_from(value: {type}) -> ::bebop::DeResult<Self>", _tab, () =>
                        {
                            builder.CodeBlock("match value", _tab, () =>
                            {
                                foreach (var m in d.Members)
                                {
                                    builder.AppendLine(
                                        $"{m.ConstantValue} => Ok({name}::{MakeEnumVariantIdent(m.Name)}),");
                                }

                                builder.AppendLine(
                                    "d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d as i128)),");
                            });
                        });
                }).AppendLine();

                // conversion to int
                builder.CodeBlock($"impl ::core::convert::From<{name}> for {type}", _tab, () =>
                {
                    builder.CodeBlock($"fn from(value: {name}) -> Self", _tab, () =>
                    {
                        builder.CodeBlock("match value", _tab, () =>
                        {
                            foreach (var m in d.Members)
                            {
                                builder.AppendLine($"{name}::{MakeEnumVariantIdent(m.Name)} => {m.ConstantValue},");
                            }
                        });
                    });
                }).AppendLine();
            }

            // sub record
            builder.CodeBlock($"impl ::bebop::SubRecord<'_> for {name}", _tab, () =>
            {
                builder
                    .AppendLine($"const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<{type}>();")
                    .AppendLine($"const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<{type}>());")
                    .AppendLine()
                    .AppendLine("#[inline]")
                    .AppendLine($"fn serialized_size(&self) -> usize {{ ::std::mem::size_of::<{type}>() }}")
                    .AppendLine()
                    .AppendLine("#[inline]")
                    .CodeBlock(
                        "fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize>",
                        _tab,
                        () =>
                        {
                            var conv = d.IsBitFlags ? "(*self).bits()" : $"{type}::from(*self)";
                            builder.AppendLine($"{conv}._serialize_chained(dest)");
                        })
                    .AppendLine()
                    .AppendLine("#[inline]")
                    .CodeBlock("fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)>", _tab,
                        () =>
                        {
                            builder.AppendLine($"let (n, v) = {type}::_deserialize_chained(raw)?;");
                            var conv = d.IsBitFlags ? "unsafe { Self::from_bits_unchecked(v) }" : "v.try_into()?";
                            builder.AppendLine($"Ok((n, {conv}))");
                        });
            }).AppendLine();

            builder.CodeBlock($"impl ::bebop::FixedSized for {name}", _tab, () =>
            {
                builder.AppendLine($"const SERIALIZED_SIZE: usize = ::std::mem::size_of::<{type}>();");
            }).AppendLine();
        }

        private void WriteStructDefinition(IndentedStringBuilder bldr, StructDefinition d, CodeRegion region)
        {
            var needsLifetime = NeedsLifetime(d);
            var ident = MakeDefIdent(d.Name);
            var isFixedSize = d.IsFixedSize(Schema);

            if (!needsLifetime && region == CodeRegion.Owned)
            {
                bldr.AppendLine($"pub use super::{ident};");
                return;
            }

            WriteDocumentation(bldr, d.Documentation);

            var ot = region switch
            {
                CodeRegion.Main => OwnershipType.Borrowed,
                CodeRegion.Owned => OwnershipType.Owned,
                _ => throw new ArgumentOutOfRangeException(nameof(region), region, null)
            };

            // if it is the owned region, skip lifetime
            var lifetime = needsLifetime && region != CodeRegion.Owned ? "'raw" : "";
            var name = needsLifetime && region != CodeRegion.Owned ? $"{ident}<'raw>" : ident;

            bldr.Append("#[derive(Clone, Debug, PartialEq");
            if (isFixedSize)
            {
                // this will allow us access it in a raw buffer without copying it.
                bldr.AppendEnd(", Copy)]")
                    .AppendLine("#[repr(packed)]");
            }
            else
            {
                bldr.AppendEnd(")]");
            }

            bldr.CodeBlock($"pub struct {name}", _tab, () => WriteStructDefinitionAttrs(bldr, d, ot))
                .AppendLine();

            if (isFixedSize)
            {
                bldr.AppendLine($"impl ::bebop::FixedSized for {name} {{}}")
                    .AppendLine();
            }

            if (region == CodeRegion.Owned)
            {
                bldr.CodeBlock($"impl<'raw> ::core::convert::From<super::{ident}<'raw>> for {ident}", _tab, () =>
                {
                    bldr.CodeBlock($"fn from(value: super::{ident}) -> Self", _tab, () =>
                    {
                        WriteFromBorrowedToOwnedForFields(bldr, d.Fields);
                    });
                }).AppendLine();
            }

            if (d.Fields.Count <= 4)
            {
                // impl From as long as it has no more than 4 values. Over that and people really should use the names
                // to prevent mistakes.
                var typeName = d.Fields.Count switch
                {
                    0 => "()",
                    1 => TypeName(d.Fields.First().Type, ot),
                    _ => $"({string.Join(", ", d.Fields.Select(f => TypeName(f.Type, ot)))})",
                };

                bldr.CodeBlock($"impl<{lifetime}> ::core::convert::From<{typeName}> for {name}", _tab, () =>
                {
                    bldr.CodeBlock($"fn from(value: {typeName}) -> Self", _tab, () =>
                    {
                        bldr.AppendLine(d.Fields.Count switch
                        {
                            0 => "Self {}",
                            1 => $"Self {{ {MakeAttrIdent(d.Fields.First().Name)}: value }}",
                            _ =>
                                $"Self {{ {string.Join(", ", d.Fields.Enumerated().Select(itr => $"{MakeAttrIdent(itr.value.Name)}: value.{itr.index}"))} }}"
                        });
                    });
                }).AppendLine();
            }

            if (d.Fields.Count <= 1)
            {
                // impl reverse From
                var typeName = d.Fields.Count == 0 ? "()" : TypeName(d.Fields.First().Type, ot);

                bldr.CodeBlock($"impl<{lifetime}> ::core::convert::From<{name}> for {typeName}", _tab, () =>
                {
                    bldr.CodeBlock($"fn from(value: {name}) -> Self", _tab, () =>
                    {
                        bldr.AppendLine(d.Fields.Count == 0 ? "()" : $"value.{MakeAttrIdent(d.Fields.First().Name)}");
                    });
                }).AppendLine();
            }

            if (d.Fields.Count == 1)
            {
                // impl Deref for structs with only one value
                var attrName = MakeAttrIdent(d.Fields.First().Name);
                bldr.CodeBlock($"impl<{lifetime}> ::core::ops::Deref for {name}", _tab, () =>
                    {
                        bldr.AppendLine($"type Target = {TypeName(d.Fields.First().Type, ot)};")
                            .AppendLine()
                            .CodeBlock("fn deref(&self) -> &Self::Target", _tab, () =>
                            {
                                bldr.AppendLine($"&self.{attrName}");
                            });
                    }).AppendLine()
                    .CodeBlock($"impl<{lifetime}> ::core::ops::DerefMut for {name}", _tab, () =>
                    {
                        bldr.CodeBlock("fn deref_mut(&mut self) -> &mut Self::Target", _tab, () =>
                        {
                            bldr.AppendLine($"&mut self.{attrName}");
                        });
                    }).AppendLine();
            }

            bldr.CodeBlock($"impl<'raw> ::bebop::SubRecord<'raw> for {name}", _tab, () =>
            {
                if (isFixedSize)
                {
                    bldr
                        .AppendLine("const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;")
                        .AppendLine("const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);")
                        .AppendLine();
                }
                else
                {
                    // sum size of all fields at compile time
                    bldr.AppendLine("const MIN_SERIALIZED_SIZE: usize =");
                    var parts = d.Fields.Select(f =>
                        $"<{TypeName(f.Type, ot)}>::MIN_SERIALIZED_SIZE");
                    bldr.Indent(_tab).Append(string.Join(" +\n", parts)).AppendEnd(";").Dedent(_tab)
                        .AppendLine();
                }

                bldr.AppendLine("#[inline]").CodeBlock("fn serialized_size(&self) -> usize", _tab, () =>
                    {
                        if (isFixedSize)
                        {
                            bldr.AppendLine("Self::SERIALIZED_SIZE");
                        }
                        else
                        {
                            bldr.AppendLine(string.Join(" +\n",
                                d.Fields.Select(
                                    (f) => $"self.{MakeAttrIdent(f.Name)}.serialized_size()"
                                )));
                        }
                    })
                    .AppendLine();

                bldr.CodeBlock(
                        "fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize>",
                        _tab, () =>
                        {
                            if (d.Fields.Count == 0)
                            {
                                bldr.AppendLine("Ok(0)");
                            }
                            else
                            {
                                // just serialize all fields and sum their bytes written
                                bldr.CodeBlock("Ok(", _tab, () =>
                                {
                                    bldr.AppendLine(string.Join(" +\n",
                                        d.Fields.Select(
                                            (f) => $"self.{MakeAttrIdent(f.Name)}._serialize_chained(dest)?")));
                                }, "", ")");
                            }
                        })
                    .AppendLine();

                bldr.CodeBlock("fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)>",
                    _tab,
                    () =>
                    {
                        WriteStructDeserialization(bldr, d);
                    });
            }).AppendLine();

            WriteRecordImpl(bldr, name, d);
        }

        /// <summary>
        /// Write the part within the `pub struct` definition. This will just write the attributes.
        /// </summary>
        private void WriteStructDefinitionAttrs(IndentedStringBuilder builder, StructDefinition d, OwnershipType ot,
            bool makePub = true)
        {
            foreach (var f in d.Fields)
            {
                WriteDocumentation(builder, f.Documentation);
                WriteDeprecation(builder, f.DeprecatedAttribute);
                var pub = makePub ? "pub " : "";
                builder.AppendLine($"{pub}{MakeAttrIdent(f.Name)}: {TypeName(f.Type, ot)},");
            }
        }

        private void WriteStructDeserialization(IndentedStringBuilder builder, StructDefinition d,
            bool externalIter = false, string selfClass = "Self", bool directReturn = false)
        {
            if (d.Fields.Count == 0)
            {
                builder.AppendLine(directReturn ? $"{selfClass} {{}}" : $"Ok((0, {selfClass} {{}}))");
                return;
            }

            if (!externalIter)
            {
                builder.AppendLine("let mut i = 0;");
            }

            if (selfClass == "Self")
            {
                builder.CodeBlock("if raw.len() - i < Self::MIN_SERIALIZED_SIZE", _tab, () =>
                {
                    builder
                        .AppendLine("let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);")
                        .AppendLine("return Err(::bebop::DeserializeError::MoreDataExpected(missing));");
                }).AppendLine();
            }

            var vars = new LinkedList<(string, string)>();
            var j = 0;
            foreach (var f in d.Fields)
            {
                builder
                    .AppendLine(
                        $"let (read, v{j}) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;")
                    .AppendLine("i += read;");
                vars.AddLast((MakeAttrIdent(f.Name), $"v{j++}"));
            }

            builder.AppendLine().CodeBlock((directReturn ? "" : "Ok((i, ") + $"{selfClass}", _tab, () =>
            {
                foreach (var (k, v) in vars)
                {
                    builder.AppendLine($"{k}: {v},");
                }
            }, "{", directReturn ? "}" : "}))");
        }

        private void WriteMessageDefinition(IndentedStringBuilder builder, MessageDefinition d, CodeRegion region)
        {
            WriteDocumentation(builder, d.Documentation);
            var needsLifetime = NeedsLifetime(d);
            var ident = MakeDefIdent(d.Name);

            if (!needsLifetime && region == CodeRegion.Owned)
            {
                builder.AppendLine($"pub use super::{ident};");
                return;
            }

            var ot = region switch
            {
                CodeRegion.Main => OwnershipType.Borrowed,
                CodeRegion.Owned => OwnershipType.Owned,
                _ => throw new ArgumentOutOfRangeException(nameof(region), region, null)
            };
            var name = ot == OwnershipType.Borrowed && needsLifetime ? $"{ident}<'raw>" : ident;

            builder
                .AppendLine("#[derive(Clone, Debug, PartialEq, Default)]")
                .CodeBlock($"pub struct {name}", _tab, () => WriteMessageDefinitionAttrs(builder, d, ot))
                .AppendLine();

            if (region == CodeRegion.Owned)
            {
                builder.CodeBlock($"impl<'raw> ::core::convert::From<super::{ident}<'raw>> for {ident}", _tab, () =>
                {
                    builder.CodeBlock($"fn from(value: super::{ident}) -> Self", _tab, () =>
                    {
                        WriteFromBorrowedToOwnedForFields(builder, d.Fields, true);
                    });
                }).AppendLine();
            }

            builder
                .CodeBlock($"impl<'raw> ::bebop::SubRecord<'raw> for {name}", _tab, () =>
                {
                    // messages are size in bytes + null byte end
                    builder
                        .AppendLine("const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;")
                        .AppendLine()
                        .AppendLine("#[inline]")
                        .CodeBlock("fn serialized_size(&self) -> usize", _tab, () =>
                        {
                            WriteMessageSizeBound(builder, d);
                        })
                        .AppendLine()
                        .CodeBlock(
                            "fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize>",
                            _tab, () =>
                            {
                                WriteMessageSerialization(builder, d);
                            }).AppendLine();

                    builder.CodeBlock("fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)>",
                        _tab,
                        () => WriteMessageDeserialization(builder, d));
                }).AppendLine();

            WriteRecordImpl(builder, name, d);
        }

        /// <summary>
        /// Write the part within the `pub struct` definition. This will just write the attributes.
        /// </summary>
        private void WriteMessageDefinitionAttrs(IndentedStringBuilder builder, MessageDefinition d, OwnershipType ot,
            bool makePub = true)
        {
            foreach (var f in d.Fields.OrderBy((f) => f.ConstantValue))
            {
                WriteDocumentation(builder, f.Documentation);
                WriteDocumentation(builder, $"Field {f.ConstantValue}");
                WriteDeprecation(builder, f.DeprecatedAttribute);
                var pub = makePub ? "pub " : "";
                builder.AppendLine($"{pub}{MakeAttrIdent(f.Name)}: ::core::option::Option<{TypeName(f.Type, ot)}>,");
            }
        }

        private void WriteMessageSizeBound(IndentedStringBuilder builder, MessageDefinition d, string obj = "self")
        {
            obj = string.IsNullOrEmpty(obj) ? "_" : $"{obj}.";
            var eol = d.Fields.Count > 0 ? " +" : "";
            builder.AppendLine($"::bebop::LEN_SIZE + 1{eol}");
            builder.AppendLine(string.Join(" +\n",
                d.Fields.Select(
                    // add 1 for opcode
                    (f) => $"{obj}{MakeAttrIdent(f.Name)}.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)"
                )));
        }

        private void WriteMessageSerialization(IndentedStringBuilder builder, MessageDefinition d,
            bool calcSize = true, string obj = "self")
        {
            obj = string.IsNullOrEmpty(obj) ? "_" : $"{obj}.";
            if (calcSize)
            {
                builder
                    .AppendLine($"let size = {obj}serialized_size();")
                    // length is not part of the body, so sub
                    .AppendLine("::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;");
            }

            // message needs if let for each field to only serialize if present.
            foreach (var f in d.Fields.OrderBy((f) => f.ConstantValue))
            {
                builder.CodeBlock($"if let Some(ref v) = {obj}{MakeAttrIdent(f.Name)}", _tab, () =>
                {
                    builder
                        .AppendLine($"{f.ConstantValue}u8._serialize_chained(dest)?;")
                        .AppendLine("v._serialize_chained(dest)?;");
                });
            }

            builder.AppendLine("0u8._serialize_chained(dest)?;");
            if (calcSize)
            {
                builder.AppendLine("Ok(size)");
            }
        }

        private void WriteMessageDeserialization(IndentedStringBuilder builder, MessageDefinition d,
            bool externalIter = false, string selfClass = "Self", bool directReturn = false)
        {
            if (!externalIter)
            {
                builder.AppendLine("let mut i = 0;");
            }

            var plusI = externalIter ? " + i" : "";
            builder
                .AppendLine($"let len = ::bebop::read_len(&raw[i..])?{plusI} + ::bebop::LEN_SIZE;")
                .AppendLine($"i += ::bebop::LEN_SIZE;")
                .AppendLine()
                .AppendLine("#[cfg(not(feature = \"bebop-unchecked\"))]")
                .CodeBlock("if len == 0", _tab, () =>
                {
                    builder.AppendLine("return Err(::bebop::DeserializeError::CorruptFrame);");
                }).AppendLine();
            builder.CodeBlock($"if raw.len() < len", _tab, () =>
            {
                builder.AppendLine(
                    "return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));");
            }).AppendLine();

            // define vars
            foreach (var f in d.Fields.OrderBy((f) => f.ConstantValue))
            {
                builder.AppendLine($"let mut _{MakeAttrIdent(f.Name)} = None;");
            }

            builder
                .AppendLine()
                .AppendLine("#[cfg(not(feature = \"bebop-unchecked\"))]")
                .AppendLine("let mut last = 0;")
                .AppendLine();

            builder.CodeBlock("while i < len", _tab, () =>
            {
                builder
                    .AppendLine("let di = raw[i];")
                    .AppendLine()
                    .AppendLine("#[cfg(not(feature = \"bebop-unchecked\"))]")
                    .CodeBlock("if di != 0", _tab, () =>
                    {
                        builder.CodeBlock("if di < last", _tab, () =>
                        {
                            builder.AppendLine(
                                "return Err(::bebop::DeserializeError::CorruptFrame);");
                        });
                        builder.AppendLine("last = di;");
                    })
                    .AppendLine()
                    .AppendLine("i += 1;");
                builder.CodeBlock("match di", _tab, () =>
                {
                    builder.CodeBlock("0 =>", _tab, () =>
                    {
                        builder.AppendLine("break;");
                    });
                    foreach (var f in d.Fields.OrderBy((f) => f.ConstantValue))
                    {
                        var fname = MakeAttrIdent(f.Name);
                        builder.CodeBlock($"{f.ConstantValue} =>", _tab, () =>
                        {
                            builder.AppendLine("#[cfg(not(feature = \"bebop-unchecked\"))]");
                            builder.CodeBlock($"if _{fname}.is_some()", _tab, () =>
                            {
                                builder.AppendLine(
                                    "return Err(::bebop::DeserializeError::DuplicateMessageField);");
                            });
                            builder
                                .AppendLine(
                                    $"let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;")
                                .AppendLine("i += read;")
                                .AppendLine($"_{fname} = Some(value)");
                        });
                    }

                    builder.CodeBlock("_ =>", _tab, () =>
                    {
                        builder
                            .AppendLine("i = len;")
                            .AppendLine("break;");
                    });
                });
            }).AppendLine();
            builder.CodeBlock("if i != len", _tab, () =>
            {
                builder
                    .AppendLine("debug_assert!(i > len);")
                    .AppendLine("return Err(::bebop::DeserializeError::CorruptFrame)");
            });

            builder.AppendLine().CodeBlock((directReturn ? "" : "Ok((i, ") + $"{selfClass}", _tab, () =>
            {
                foreach (var f in d.Fields.OrderBy((f) => f.ConstantValue))
                {
                    var fieldName = MakeAttrIdent(f.Name);
                    builder.AppendLine($"{fieldName}: _{fieldName},");
                }
            }, "{", directReturn ? "}" : "}))");
        }

        private void WriteUnionDefinition(IndentedStringBuilder builder, UnionDefinition d, CodeRegion region)
        {
            var ident = MakeDefIdent(d.Name);
            var needsLifetime = NeedsLifetime(d);
            if (!needsLifetime && region == CodeRegion.Owned)
            {
                builder.AppendLine($"pub use super::{ident};");
                return;
            }

            WriteDocumentation(builder, d.Documentation);

            var ot = region switch
            {
                CodeRegion.Main => OwnershipType.Borrowed,
                CodeRegion.Owned => OwnershipType.Owned,
                _ => throw new ArgumentOutOfRangeException(nameof(region), region, null)
            };
            var name = ot == OwnershipType.Borrowed && needsLifetime ? $"{ident}<'raw>" : ident;

            builder.AppendLine("#[derive(Clone, Debug, PartialEq)]");
            builder.CodeBlock($"pub enum {name}", _tab, () =>
            {
                if (d.Branches.Any(b => b.Definition.Name == "Unknown"))
                {
                    throw new Exception("Unknown is a reserved Union branch name");
                }

                WriteDocumentation(builder,
                    "An unknown type which is likely defined in a newer version of the schema.");
                builder.AppendLine("Unknown,");

                foreach (var b in d.Branches.OrderBy((b) => b.Discriminator))
                {
                    builder.AppendLine();
                    WriteDocumentation(builder, b.Definition.Documentation);
                    WriteDocumentation(builder, $"Discriminator {b.Discriminator}");
                    builder.CodeBlock(MakeEnumVariantIdent(b.Definition.Name), _tab, () =>
                    {
                        switch (b.Definition)
                        {
                            case StructDefinition sd:
                                WriteStructDefinitionAttrs(builder, sd, ot, false);
                                break;
                            case MessageDefinition md:
                                WriteMessageDefinitionAttrs(builder, md, ot, false);
                                break;
                            default:
                                throw new ArgumentOutOfRangeException(b.Definition.ToString());
                        }
                    }, "{", "},");
                }
            }).AppendLine();

            if (region == CodeRegion.Owned)
            {
                builder.CodeBlock($"impl<'raw> ::core::convert::From<super::{ident}<'raw>> for {ident}", _tab, () =>
                {
                    builder.CodeBlock($"fn from(value: super::{ident}) -> Self", _tab, () =>
                    {
                        builder.CodeBlock("match value", _tab, () =>
                        {
                            builder.CodeBlock($"super::{ident}::Unknown =>", _tab, () =>
                            {
                                builder.AppendLine("Self::Unknown");
                            });
                            // matching against each possible union type
                            foreach (var b in d.Branches.OrderBy(b => b.Discriminator))
                            {
                                WriteUnionDestructuringForBranch(builder, b, $"super::{ident}", false);
                                var variantIdent = MakeEnumVariantIdent(b.Definition.Name);
                                var obj = $"Self::{variantIdent}";
                                builder.CodeBlock("=>", _tab, () =>
                                {
                                    switch (b.Definition)
                                    {
                                        case StructDefinition sd:
                                            WriteFromBorrowedToOwnedForFields(builder, sd.Fields, false, obj, "_");
                                            break;
                                        case MessageDefinition md:
                                            WriteFromBorrowedToOwnedForFields(builder, md.Fields, true, obj, "_");
                                            break;
                                        default:
                                            throw new ArgumentOutOfRangeException(b.Definition.ToString());
                                    }
                                });
                            }
                        });
                    }).AppendLine();
                });
            }

            builder.CodeBlock($"impl<'raw> ::bebop::SubRecord<'raw> for {name}", _tab, () =>
            {
                builder
                    .AppendLine("const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;")
                    .AppendLine();

                builder.CodeBlock("fn serialized_size(&self) -> usize", _tab, () =>
                {
                    builder.AppendLine("::bebop::LEN_SIZE + 1 +");
                    builder.CodeBlock("match self", _tab, () =>
                    {
                        builder.CodeBlock($"{ident}::Unknown =>", _tab, () =>
                        {
                            builder.AppendLine("0");
                        });
                        // matching against each possible union type
                        foreach (var b in d.Branches.OrderBy(b => b.Discriminator))
                        {
                            WriteUnionDestructuringForBranch(builder, b);
                            builder.CodeBlock("=>", _tab, () =>
                            {
                                // summation
                                switch (b.Definition)
                                {
                                    case StructDefinition sd:
                                        if (sd.Fields.Count == 0)
                                        {
                                            builder.AppendLine("0");
                                        }
                                        else
                                        {
                                            builder.AppendLine(string.Join(" +\n",
                                                sd.Fields.Select(
                                                    (f) => $"_{MakeAttrIdent(f.Name)}.serialized_size()"
                                                )));
                                        }

                                        break;
                                    case MessageDefinition md:
                                        WriteMessageSizeBound(builder, md, "");
                                        break;
                                    default:
                                        throw new ArgumentOutOfRangeException(b.Definition.ToString());
                                }
                            });
                        }
                    });
                }).AppendLine();

                builder.CodeBlock(
                    "fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize>",
                    _tab, () =>
                    {
                        builder.AppendLine("let size = self.serialized_size();")
                            // the length and discriminators are not part of the body
                            .AppendLine("::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;");
                        builder.CodeBlock("match self", _tab, () =>
                        {
                            builder.CodeBlock($"{ident}::Unknown =>", _tab, () =>
                            {
                                builder.AppendLine(
                                    "return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);");
                            });
                            // matching against each possible union type
                            foreach (var b in d.Branches.OrderBy((b) => b.Discriminator))
                            {
                                WriteUnionDestructuringForBranch(builder, b);
                                builder.CodeBlock("=>", _tab, () =>
                                {
                                    // serialization
                                    builder.AppendLine($"{b.Discriminator}u8._serialize_chained(dest)?;");
                                    switch (b.Definition)
                                    {
                                        case StructDefinition sd:
                                            foreach (var sdField in sd.Fields)
                                            {
                                                builder.AppendLine(
                                                    $"_{MakeAttrIdent(sdField.Name)}._serialize_chained(dest)?;");
                                            }

                                            break;
                                        case MessageDefinition md:
                                            // calculate size of message by taking union size and subbing union length and discriminator
                                            builder.AppendLine(
                                                "::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;");
                                            WriteMessageSerialization(builder, md, false, "");
                                            break;
                                        default:
                                            throw new ArgumentOutOfRangeException(b.Definition.ToString());
                                    }
                                });
                            }
                        });

                        builder
                            .AppendLine("Ok(size)");
                    }).AppendLine();

                builder.CodeBlock("fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)>",
                    _tab,
                    () =>
                    {
                        builder
                            // add 1 for discriminator
                            .AppendLine("let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;")
                            .AppendLine("let mut i = ::bebop::LEN_SIZE + 1;");

                        builder.CodeBlock("let de = match raw[::bebop::LEN_SIZE]", _tab, () =>
                        {
                            // matching against each possible union type
                            foreach (var b in d.Branches.OrderBy((b) => b.Discriminator))
                            {
                                var branchName = MakeEnumVariantIdent(b.Definition.Name);
                                builder.CodeBlock($"{b.Discriminator} =>", _tab, () =>
                                {
                                    switch (b.Definition)
                                    {
                                        case StructDefinition sd:
                                            WriteStructDeserialization(builder, sd, true, $"{ident}::{branchName}",
                                                true);
                                            break;
                                        case MessageDefinition md:
                                            WriteMessageDeserialization(builder, md, true, $"{ident}::{branchName}",
                                                true);
                                            break;
                                        default:
                                            throw new ArgumentOutOfRangeException(b.Definition.ToString());
                                    }
                                });
                            }

                            builder.CodeBlock($"_ =>", _tab, () =>
                            {
                                builder
                                    .AppendLine("i = len;")
                                    .AppendLine($"{ident}::Unknown");
                            });
                        }, "{", "};");
                        builder.CodeBlock("if !cfg!(feature = \"bebop-unchecked\") && i != len", _tab,
                            () =>
                            {
                                builder
                                    .AppendLine("debug_assert!(i > len);")
                                    .AppendLine("Err(::bebop::DeserializeError::CorruptFrame)");
                            });
                        builder.CodeBlock("else", _tab, () =>
                        {
                            builder.AppendLine("Ok((i, de))");
                        });
                    }).AppendLine();
            }).AppendLine();

            WriteRecordImpl(builder, name, d);
        }

        /// <summary>
        /// Write the destructuring for a given union branch. Names all attributes with a `_` prefix to avoid
        /// collisions. This does not write the "=>" opening.
        /// </summary>
        private void WriteUnionDestructuringForBranch(IndentedStringBuilder builder, UnionBranch b, string obj = "Self",
            bool byRef = true)
        {
            var branchName = MakeEnumVariantIdent(b.Definition.Name);
            var refStr = byRef ? " ref" : "";
            builder.CodeBlock($"{obj}::{branchName}", _tab, () =>
            {
                if (b.Definition is FieldsDefinition fd)
                {
                    foreach (var field in fd.Fields)
                    {
                        var fieldName = MakeAttrIdent(field.Name);
                        builder.AppendLine($"{fieldName}:{refStr} _{fieldName},");
                    }
                }
                else
                {
                    throw new ArgumentOutOfRangeException(b.Definition.ToString());
                }
            });
        }

        #endregion

        #region rpc

        private void WriteServiceDefinition(IndentedStringBuilder bldr, ServiceDefinition d)
        {
            var ident = MakeDefIdent(d.Name);
            var requestsFeat = $"#[cfg(feature = \"{MakeFeatureIdent(ident)}-requests\")]";
            var handlersFeat = $"#[cfg(feature = \"{MakeFeatureIdent(ident)}-handlers\")]";
            var serviceBranches = d.Branches.OrderBy(d => d.Discriminator).ToImmutableArray();

            WriteDocumentation(bldr, d.Documentation);
            bldr.AppendLine(handlersFeat)
                .CodeBlock($"pub trait {ident}HandlersDef: ::core::marker::Send + ::core::marker::Sync", _tab, () =>
                {
                    bldr.CodeBlock(
                        $"fn service_name<'f>(&self, handle: ::bebop::rpc::TypedRequestHandle<'f, super::{ident}ServiceNameReturn<'f>>) -> {DynFutType("()")}",
                        _tab,
                        () =>
                        {
                            bldr.AppendLine("use ::bebop::rpc::CallDetails as _;")
                                .AppendLine("let call_id = handle.call_id().get();")
                                .AppendLine(
                                    $"::bebop::dyn_fut! {{ ::bebop::handle_respond_error!(handle.send_ok_response(&super::{ident}ServiceNameReturn {{ value: \"{ident}\" }}), \"{ident}\", \"service_name\", 0, call_id); }}");
                        });
                    foreach (var (b, i) in d.Branches.OrderBy(d => d.Discriminator).Skip(1).Enumerated())
                    {
                        var fn = b.Definition;
                        WriteDocumentation(bldr, fn.Documentation);
                        WriteDeprecation(bldr, fn.Attributes);
                        var fname = MakeFnIdent(fn.Name);
                        var args = fn.ArgumentStruct.Fields.Select(f =>
                            (MakeFnArgIdent(f.Name), TypeName(f.Type, OwnershipType.Owned))).ToArray();
                        var retType = MakeDefIdent(fn.ReturnStruct.Name);
                        var lt = NeedsLifetime(fn.ReturnStruct) ? "<'f>" : "";
                        var argsStr = string.Join(", ",
                            new[] { "&self", $"_handle: ::bebop::rpc::TypedRequestHandle<'f, super::{retType}{lt}>" }
                                .Concat(args.Select(i => $"{i.Item1}: {i.Item2}")));
                        bldr.AppendLine($"fn {fname}<'f>({argsStr}) -> {DynFutType("()")};");
                        if (i < d.Branches.Count - 1) bldr.AppendLine();
                    }
                })
                .AppendLine()
                .AppendLine(handlersFeat)
                .AppendLine("#[repr(transparent)]")
                .AppendLine($"pub struct {ident}Handlers<_Def: {ident}HandlersDef>(_Def);")
                .AppendLine()
                .AppendLine(handlersFeat)
                .CodeBlock($"impl<_Def: {ident}HandlersDef> ::core::convert::From<_Def> for {ident}Handlers<_Def>",
                    _tab, () =>
                    {
                        bldr.AppendLine("fn from(def: _Def) -> Self { Self(def) }");
                    })
                .AppendLine()
                .AppendLine(handlersFeat)
                .CodeBlock($"impl<_Def: {ident}HandlersDef> ::core::ops::Deref for {ident}Handlers<_Def>", _tab, () =>
                {
                    bldr.AppendLine("type Target = _Def;")
                        .AppendLine()
                        .AppendLine("fn deref(&self) -> &Self::Target { &self.0 }");
                })
                .AppendLine()
                .AppendLine(handlersFeat)
                .CodeBlock($"impl<_Def: {ident}HandlersDef> ::bebop::rpc::ServiceHandlers for {ident}Handlers<_Def>",
                    _tab, () =>
                    {
                        bldr.AppendLine($"fn _name(&self) -> &'static str {{ \"{ident}\" }}")
                            .AppendLine()
                            .CodeBlock(
                                $"fn _recv_call<'f>(&self, datagram: &::bebop::rpc::Datagram, handle: ::bebop::rpc::RequestHandle) -> {DynFutType("()")}",
                                _tab, () =>
                                {
                                    bldr.AppendLine("use ::bebop::rpc::CallDetails as _;")
                                        .CodeBlock(
                                            "if let ::bebop::rpc::Datagram::RpcRequestDatagram { header: req_header, opcode, data } = datagram",
                                            _tab, () =>
                                            {
                                                bldr.AppendLine("let call_id = req_header.id;")
                                                    .AppendLine("let opcode = *opcode;")
                                                    .CodeBlock("match opcode", _tab, () =>
                                                    {
                                                        foreach (var b in serviceBranches)
                                                        {
                                                            bldr.CodeBlock($"{b.Discriminator} =>", _tab,
                                                                () =>
                                                                {
                                                                    WriteRpcHandlerFnCall(bldr, b.Definition);
                                                                });
                                                        }

                                                        bldr.AppendLine(
                                                            $"_ => ::bebop::dyn_fut! {{ ::bebop::handle_respond_error!(handle.send_unknown_call_response(), \"{ident}\", \"UNKNOWN\", opcode, call_id); }},");
                                                    });
                                            }, "{",
                                            "} else { unreachable!(\"`_recv_call` Should only ever be provided with Requests.\") }");
                                });
                    }).AppendLine();

            WriteDocumentation(bldr, d.Documentation);
            bldr.AppendLine(requestsFeat)
                .AppendLine("#[derive(Clone)]")
                .AppendLine(
                    $"pub struct {ident}Requests(::std::sync::Weak<::bebop::rpc::RouterContext>);")
                .AppendLine()
                .AppendLine(requestsFeat)
                .CodeBlock($"impl {ident}Requests", _tab, () =>
                {
                    foreach (var b in serviceBranches)
                    {
                        WriteRpcRequesterFn(bldr, b.Discriminator, b.Definition);
                    }
                })
                .AppendLine()
                .AppendLine(requestsFeat)
                .CodeBlock($"impl ::bebop::rpc::ServiceRequests for {ident}Requests", _tab,
                    () =>
                    {
                        bldr.AppendLine($"const NAME: &'static str = \"{ident}\";")
                            .AppendLine()
                            .CodeBlock("fn new(ctx: ::std::sync::Weak<::bebop::rpc::RouterContext>) -> Self",
                                _tab,
                                () =>
                                {
                                    bldr.AppendLine("Self(ctx)");
                                });
                    });
        }

        /// <summary>
        /// Write the code which unpacks the argument struct, checks the function signature, calls the appropriate
        /// function, and then packs the return value and submits it to `tx`.
        /// </summary>
        private static void WriteRpcHandlerFnCall(IndentedStringBuilder bldr, FunctionDefinition fnDef)
        {
            var serviceName = MakeDefIdent(fnDef.Parent!.Name);
            var fnName = MakeFnIdent(fnDef.Name);
            var sigName = MakeConstIdent(fnDef.Signature.Name);
            var argsName = MakeDefIdent(fnDef.ArgumentStruct.Name);
            var retName = MakeDefIdent(fnDef.ReturnStruct.Name);

            bldr.CodeBlock($"if req_header.signature != {sigName}", _tab, () =>
            {
                bldr.AppendLine(
                    $"return ::bebop::dyn_fut! {{ ::bebop::handle_respond_error!(handle.send_invalid_sig_response({sigName}), \"{serviceName}\", \"{fnName}\", opcode, call_id); }}");
            });

            if (fnDef.ArgumentStruct.Fields.Count > 0)
            {
                bldr.CodeBlock($"let args = match {argsName}::deserialize(data)", _tab, () =>
                {
                    bldr.AppendLine("Ok(args) => args,")
                        .AppendLine(
                            $"Err(err) => return ::bebop::dyn_fut! {{ ::bebop::handle_respond_error!(handle.send_decode_error_response(Some(&err.to_string())), \"{serviceName}\", \"{fnName}\", opcode, call_id) }}");
                }, "{", "};");
            }

            bldr.Append($"self.{fnName}(")
                .AppendMid(string.Join(", ",
                    new[] { "handle.into()" }.Concat(
                        fnDef.ArgumentStruct.Fields.Select(f => $"args.{MakeAttrIdent(f.Name)}"))))
                .AppendEnd(")");
        }

        private void WriteRpcRequesterFn(IndentedStringBuilder bldr, ushort opcode, FunctionDefinition fnDef)
        {
            var fnName = MakeFnIdent(fnDef.Name);
            var sigName = MakeConstIdent(fnDef.Signature.Name);
            var argName = MakeDefIdent(fnDef.ArgumentStruct.Name);
            var retName = MakeDefIdent(fnDef.ReturnStruct.Name);
            const string timeoutArg = "timeout: ::core::option::Option<::core::time::Duration>";

            var args = fnDef.ArgumentStruct.Fields.Select(i =>
                (MakeAttrIdent(i.Name), TypeName(i.Type, OwnershipType.Borrowed, "'_", "super::"))).ToImmutableArray();
            var argString = string.Join(", ",
                new[] { "&self", timeoutArg }.Concat(args.Select(i =>
                    $"{i.Item1}: {i.Item2}")));
            var retType = fnDef.ReturnStruct.Fields.Count > 0
                ? TypeName(fnDef.ReturnStruct.Fields.First().Type, OwnershipType.Owned)
                : "()";

            WriteDocumentation(bldr, fnDef.Documentation);
            WriteDeprecation(bldr, fnDef.Attributes);
            bldr.AppendLine("#[inline]")
                .CodeBlock($"pub async fn {fnName}({argString}) -> ::bebop::rpc::RemoteRpcResponse<{retType}>", _tab,
                    () =>
                    {
                        var argsString = string.Join(", ", args.Select(i => i.Item1));
                        bldr.AppendLine($"self.{fnName}_raw(timeout, &super::{argName} {{ {argsString} }})?")
                            .Append(".await")
                            .AppendEnd(fnDef.ReturnStruct.Fields.Count > 0 ? ".map(|v| v.value)" : "?; Ok(())");
                    })
                .AppendLine();

            WriteDocumentation(bldr, fnDef.Documentation);
            WriteDeprecation(bldr, fnDef.Attributes);
            bldr.CodeBlock(
                $"pub fn {fnName}_raw<'data>(&self, {timeoutArg}, payload: &'data super::{argName}) -> ::bebop::rpc::TransportResult<impl 'data + Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<{retName}>>>",
                _tab,
                () =>
                {
                    bldr.AppendLine(
                            "let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;")
                        .CodeBlock($"let fut = zelf.request::<_, {retName}>", _tab, () =>
                        {
                            bldr.AppendLine($"{opcode}, ")
                                .AppendLine("timeout,")
                                .AppendLine($"{sigName},")
                                .AppendLine("payload,");
                        }, "(", ");")
                        .AppendLine(fnDef.ReturnStruct.Fields.Count > 0
                            ? "Ok(async move { fut.await.map(::core::convert::Into::into) })"
                            : "Ok(fut)");
                }).AppendLine();
        }

        #endregion

        #region component_writers

        private static void WriteDocumentation(IndentedStringBuilder builder, string documentation)
        {
            if (string.IsNullOrEmpty(documentation)) { return; }

            foreach (var line in documentation.GetLines())
            {
                // TODO: make the docs more friendly to rustdoc by formatting as markdown
                builder.AppendLine($"/// {line}");
            }
        }

        private static void WriteDeprecation(IndentedStringBuilder builder, BaseAttribute? attr)
        {
            if (attr is null) { return; }

            builder.Append("#[deprecated");
            if (!string.IsNullOrEmpty(attr.Value))
            {
                builder.AppendMid($"(note = \"{attr.Value}\")");
            }

            builder.AppendEnd("]");
        }

        private static void WriteRecordImpl(IndentedStringBuilder builder, string name, RecordDefinition d)
        {
            if (d.OpcodeAttribute is { Value: not (null or "") })
            {
                builder.CodeBlock($"impl<'raw> ::bebop::Record<'raw> for {name}", _tab, () =>
                {
                    builder.AppendLine(
                        $"const OPCODE: ::core::option::Option<u32> = Some({d.OpcodeAttribute.Value});");
                });
            }
            else
            {
                builder.AppendLine($"impl<'raw> ::bebop::Record<'raw> for {name} {{}}");
            }
        }


        private void WriteFromBorrowedToOwnedForFields(IndentedStringBuilder builder, IEnumerable<Field> fields,
            bool optionalFields = false, string obj = "Self", string attrPrefix = "value.") =>
            builder.CodeBlock(obj, _tab, () =>
            {
                foreach (var f in fields)
                {
                    var atrName = MakeAttrIdent(f.Name);
                    var intoMethod = BorrowedIntoOwnedMethod(f.Type);
                    if (optionalFields && intoMethod != "")
                    {
                        // we have to map because it is an optional and we can't just move
                        builder.AppendLine($"{atrName}: {attrPrefix}{atrName}.map(|value| value{intoMethod}),");
                    }
                    else
                    {
                        // we don't need to map, but we do need to convert
                        builder.AppendLine($"{atrName}: {attrPrefix}{atrName}{intoMethod},");
                    }
                }
            });

        /// <summary>
        /// Generate the `.into()` or equivalent for converting from a borrowed type to an owned type.
        /// </summary>
        private string BorrowedIntoOwnedMethod(TypeBase type)
        {
            switch (type)
            {
                // when it is a slice
                case ArrayType at when !ArrayTypeIsVec(at):
                    var cloned = (at.MemberType is ScalarType ast && ast.BaseType == BaseType.String)
                        ? ".cloned()"
                        : "";
                    return $".iter(){cloned}.map(|value| value{BorrowedIntoOwnedMethod(at.MemberType)}).collect()";
                // when it is a vec
                case ArrayType at:
                    // when no conversion is needed, take ownership of the vec, else map
                    var arrayInner = BorrowedIntoOwnedMethod(at.MemberType);
                    return string.IsNullOrEmpty(arrayInner)
                        ? ""
                        : $".into_iter().map(|value| value{arrayInner}).collect()";

                case DefinedType dt when NeedsLifetime(Schema.Definitions[dt.Name]):
                    return ".into()";
                case DefinedType:
                    return "";

                case MapType mt:
                    var keyInto = BorrowedIntoOwnedMethod(mt.KeyType);
                    var valueInto = BorrowedIntoOwnedMethod(mt.ValueType);
                    return !string.IsNullOrEmpty(keyInto) || !string.IsNullOrEmpty(valueInto)
                        // When the key OR the value need to be mapped
                        ? $".into_iter().map(|(key, value)| (key{BorrowedIntoOwnedMethod(mt.KeyType)}, value{BorrowedIntoOwnedMethod(mt.ValueType)})).collect()"
                        // When neither the key nor the value need to be mapped, just take ownership
                        : "";

                case ScalarType { BaseType: BaseType.String }:
                    return ".into()";
                case ScalarType:
                    return "";
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private string DynFutType(string output) => DynFutType("'f", output);
        private string DynFutType(string lifetime, string output) => $"::bebop::rpc::DynFuture<{lifetime}, {output}>";

        #endregion

        #region types_and_identifiers

        private static string MakeConstIdent(string ident)
        {
            var reCased = ident.ToSnakeCase().ToUpper();
            return _reservedWords.Contains(reCased)
                ? $"_{reCased}"
                : reCased;
        }

        private string MakeEnumVariantIdent(string ident) => MakeDefIdent(ident);

        private static string MakeDefIdent(string ident)
        {
            var reCased = ident.ToPascalCase();
            return _reservedWords.Contains(reCased)
                ? $"_{reCased}"
                : reCased;
        }

        private static string MakeAttrIdent(string ident)
        {
            var reCased = ident.ToSnakeCase();
            return _reservedWords.Contains(reCased)
                ? $"_{reCased}"
                : reCased;
        }

        private static string MakeFnIdent(string ident) => MakeAttrIdent(ident);

        private static string MakeFnArgIdent(string ident) => MakeAttrIdent(ident);

        private static string MakeFeatureIdent(string ident) => ident.ToKebabCase();

        /// <summary>
        /// Generate a Rust type name for the given <see cref="TypeBase"/>.
        /// </summary>
        /// <param name="type">The field type to generate code for.</param>
        /// <param name="ot">Ownership type, e.g. <c>&'raw str</c> versus <c>String</c>.</param>
        /// <returns>The Rust type name.</returns>
        private string TypeName(TypeBase type, OwnershipType ot, string lt = "'raw", string definedTypePrefix = "")
        {
            switch (type)
            {
                case ScalarType st:
                    return st.BaseType switch
                    {
                        BaseType.Bool => "bool",
                        BaseType.Byte => "u8",
                        BaseType.UInt16 => "u16",
                        BaseType.Int16 => "i16",
                        BaseType.UInt32 => "u32",
                        BaseType.Int32 => "i32",
                        BaseType.UInt64 => "u64",
                        BaseType.Int64 => "i64",
                        BaseType.Float32 => "f32",
                        BaseType.Float64 => "f64",
                        BaseType.String => ot switch
                        {
                            OwnershipType.Borrowed => $"&{lt} str",
                            OwnershipType.Constant => "&str",
                            OwnershipType.Owned => "::std::string::String",
                            _ => throw new ArgumentOutOfRangeException(nameof(ot))
                        },
                        BaseType.Guid => "::bebop::Guid",
                        BaseType.Date => "::bebop::Date",
                        _ => throw new ArgumentOutOfRangeException(st.BaseType.ToString())
                    };
                case ArrayType at:
                    if (at.MemberType is ScalarType mst && ot is OwnershipType.Borrowed or OwnershipType.Constant)
                    {
                        // TODO: expand this to make better use of the slice wrapper
                        var lifetime = ot is OwnershipType.Borrowed ? lt : "'static";
                        var wrappedSlice =
                            $"::bebop::SliceWrapper<{lifetime}, {TypeName(at.MemberType, ot, lt, definedTypePrefix)}>";
                        return mst.BaseType switch
                        {
                            BaseType.Bool => wrappedSlice,
                            BaseType.Byte => wrappedSlice,
                            BaseType.UInt16 => wrappedSlice,
                            BaseType.Int16 => wrappedSlice,
                            BaseType.UInt32 => wrappedSlice,
                            BaseType.Int32 => wrappedSlice,
                            BaseType.UInt64 => wrappedSlice,
                            BaseType.Int64 => wrappedSlice,
                            BaseType.Float32 => wrappedSlice,
                            BaseType.Float64 => wrappedSlice,
                            BaseType.String when ot is OwnershipType.Borrowed =>
                                $"::std::vec::Vec<{TypeName(at.MemberType, ot, lt, definedTypePrefix)}>",
                            BaseType.String => wrappedSlice,
                            // this one does not care what endian the system is
                            BaseType.Guid => wrappedSlice, //$"&{lifetime} [::bebop::Guid]",
                            BaseType.Date => wrappedSlice,
                            _ => throw new ArgumentOutOfRangeException(mst.BaseType.ToString())
                        };
                    }
                    else if (ot is OwnershipType.Borrowed or OwnershipType.Constant &&
                             at.MemberType is DefinedType mdt &&
                             ((Schema.Definitions[mdt.Name] is StructDefinition msd &&
                               msd.IsFixedSize(Schema)) ||
                              Schema.Definitions[mdt.Name] is EnumDefinition))
                    {
                        // extra special case where we have an array of primitive-like structs
                        var lifetime = ot is OwnershipType.Borrowed ? lt : "'static";
                        return
                            $"::bebop::SliceWrapper<{lifetime}, {TypeName(at.MemberType, ot, lt, definedTypePrefix)}>";
                    }
                    else
                    {
                        return $"::std::vec::Vec<{TypeName(at.MemberType, ot, lt, definedTypePrefix)}>";
                    }
                case MapType mt:
                    return
                        $"::std::collections::HashMap<{TypeName(mt.KeyType, ot, lt, definedTypePrefix)}, {TypeName(mt.ValueType, ot, lt, definedTypePrefix)}>";
                case DefinedType dt:
                    var dtName = MakeDefIdent(dt.Name);
                    return ot switch
                    {
                        OwnershipType.Borrowed => NeedsLifetime(Schema.Definitions[dt.Name], ot)
                            ? $"{definedTypePrefix}{dtName}<{lt}>"
                            : $"{definedTypePrefix}{dtName}",
                        OwnershipType.Owned => $"{definedTypePrefix}{dtName}",
                        OwnershipType.Constant => throw new NotSupportedException(
                            "Cannot have a const defined type"),
                        _ => throw new ArgumentOutOfRangeException(nameof(ot), ot, null)
                    };
            }

            throw new InvalidOperationException($"GetTypeName: {type}");
        }

        private bool TypeNeedsLifetime(TypeBase type, OwnershipType ot = OwnershipType.Borrowed) =>
            type switch
            {
                DefinedType dt => NeedsLifetime(Schema.Definitions[dt.Name]),
                MapType mt => TypeNeedsLifetime(mt.KeyType) || TypeNeedsLifetime(mt.ValueType),
                { } tb => TypeName(tb, ot).Contains("'raw")
            };

        private bool ArrayTypeIsVec(ArrayType type, OwnershipType ot = OwnershipType.Borrowed) =>
            TypeName(type, ot).StartsWith("::std::vec::Vec");

        private bool FieldNeedsLifetime(Definition d, Field f, OwnershipType ot = OwnershipType.Borrowed)
        {
            var key = $"{d.Name}::{f.Name}";
            if (_needsLifetime.ContainsKey(key))
            {
                return _needsLifetime[key];
            }

            _needsLifetime[key] = TypeNeedsLifetime(f.Type, ot);
            return _needsLifetime[key];
        }

        private bool NeedsLifetime(Definition d, OwnershipType ot = OwnershipType.Borrowed)
        {
            if (ot == OwnershipType.Owned)
            {
                return false;
            }

            if (_needsLifetime.ContainsKey(d.Name))
            {
                return _needsLifetime[d.Name];
            }

            _needsLifetime[d.Name] = d switch
            {
                ConstDefinition cd => false,
                EnumDefinition ed => false,
                FieldsDefinition fd => fd.Fields.Any(f => FieldNeedsLifetime(d, f, ot)),
                UnionDefinition ud => ud.Branches.Any(b => NeedsLifetime(b.Definition)),
                _ => throw new ArgumentOutOfRangeException(d.Name)
            };
            return _needsLifetime[d.Name];
        }

        #endregion

        #region literals

        private string EmitLiteral(Literal literal) =>
            literal switch
            {
                BoolLiteral bl => bl.Value ? "true" : "false",
                IntegerLiteral il => il.Value,
                FloatLiteral { Value: "inf" } => $"{TypeName(literal.Type, OwnershipType.Constant)}::INFINITY",
                FloatLiteral { Value: "-inf" } => $"{TypeName(literal.Type, OwnershipType.Constant)}::NEG_INFINITY",
                FloatLiteral { Value: "nan" } => $"{TypeName(literal.Type, OwnershipType.Constant)}::NAN",
                FloatLiteral fl => fl.Value.Contains('.') ? fl.Value : fl.Value + '.',
                StringLiteral sl => MakeStringLiteral(sl.Value),
                GuidLiteral gl => MakeGuidLiteral(gl.Value),
                _ => throw new ArgumentOutOfRangeException(literal.ToString()),
            };

        private static string MakeStringLiteral(string value) =>
            // rust accepts full UTF-8 strings in code AND even supports newlines
            value.Contains("\"#") ? value.Replace("\\", "\\\\").Replace("\"", "\\\"") : $"r#\"{value}\"#";

        private static string MakeGuidLiteral(Guid guid)
        {
            var g = guid.ToString("N").ToCharArray();
            var builder = new StringBuilder();
            builder.Append("::bebop::Guid::from_be_bytes([");
            for (var i = 0; i < g.Length; i += 2)
            {
                builder.Append("0x")
                    .Append(g[i])
                    .Append(g[i + 1])
                    .Append(',');
            }

            builder.Append("])");
            return builder.ToString();
        }

        #endregion
    }
}