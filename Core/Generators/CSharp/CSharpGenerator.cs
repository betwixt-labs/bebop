using System;
using System.Linq;
using System.Text;
using System.Text.Encodings.Web;
using System.Text.Json;
using Core.Meta;
using Core.Meta.Extensions;
using Core.Meta.Interfaces;

namespace Core.Generators.CSharp
{
    public class CSharpGenerator : BaseGenerator
    {
        private Version LanguageVersion = CSharpNine;

        public CSharpGenerator(ISchema schema) : base(schema)
        {
        }


        public override string Compile(Version? languageVersion)
        {
            if (languageVersion is not null)
            {
                LanguageVersion = languageVersion;
            }
            var builder = new IndentedStringBuilder();
            builder.AppendLine(GeneratorUtils.GetXmlAutoGeneratedNotice());
            builder.AppendLine("//");
            builder.AppendLine($"// This source code was auto-generated by {ReservedWords.CompilerName}, Version={VersionInfo.Informational}.");
            builder.AppendLine("//");

            if (!string.IsNullOrWhiteSpace(Schema.Namespace))
            {
                builder.AppendLine($"namespace {Schema.Namespace.ToPascalCase()} {{");
                builder.Indent(indentStep);
            }

            foreach (var definition in Schema.Definitions.Values)
            {
                if (!string.IsNullOrWhiteSpace(definition.Documentation))
                {
                    builder.AppendLine(FormatDocumentation(definition.Documentation, 0));
                }
                builder.AppendLine(GeneratedAttribute);
                if (definition is EnumDefinition ed)
                {
                    builder.AppendLine("[global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Enum)]");
                    builder.AppendLine($"public enum {definition.ClassName()} : uint {{");
                    builder.Indent(indentStep);
                    for (var i = 0; i < ed.Members.Count; i++)
                    {
                        var field = ed.Members.ElementAt(i);
                        if (!string.IsNullOrWhiteSpace(field.Documentation))
                        {
                            builder.AppendLine(FormatDocumentation(field.Documentation, 6));
                        }
                        if (field.DeprecatedAttribute is not null &&
                            !string.IsNullOrWhiteSpace(field.DeprecatedAttribute.Value))
                        {
                            builder.AppendLine($"[System.Obsolete(\"{field.DeprecatedAttribute.Value}\")]");
                        }
                        builder.AppendLine($"{field.Name.ToPascalCase()} = {field.ConstantValue}{(i + 1 < ed.Members.Count ? "," : "")}");
                    }
                    builder.Dedent(indentStep);
                    builder.AppendLine("}");
                    builder.AppendLine();
                }
                else if (definition is TopLevelDefinition)
                {
                    if (definition is FieldsDefinition fd)
                    {
                        var recordAttribute = fd switch
                        {
                            MessageDefinition => "[global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]",
                            StructDefinition { IsReadOnly: true } => "[global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct, true)]",
                            StructDefinition => "[global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]",
                            _ => string.Empty
                        };
                        builder.AppendLine(recordAttribute);
                        builder.AppendLine($"public partial class {definition.ClassName()} : {BebopRecord}, global::System.IEquatable<{definition.ClassName()}> {{");
                        builder.Indent(indentStep);

                        if (fd is MessageDefinition)
                        {
                            builder.AppendLine("#nullable enable");
                        }

                        if (fd.OpcodeAttribute is { Value: not null })
                        {
                            builder.AppendLine($"public const uint OpCode = {fd.OpcodeAttribute.Value};");
                        }

                        builder.AppendLine("/// <inheritdoc />");
                        builder.AppendLine($"public sealed override int MaxByteCount => GetMaxByteCount();");
                        builder.AppendLine("/// <inheritdoc />");
                        builder.AppendLine($"public sealed override int ByteCount => GetByteCount();");


                        for (var i = 0; i < fd.Fields.Count; i++)
                        {
                            var field = fd.Fields.ElementAt(i);

                            if (!string.IsNullOrWhiteSpace(field.Documentation))
                            {
                                builder.AppendLine(FormatDocumentation(field.Documentation, 0));
                            }
                            if (field.DeprecatedAttribute is not null &&
                                !string.IsNullOrWhiteSpace(field.DeprecatedAttribute.Value))
                            {
                                builder.AppendLine($"[System.Obsolete(\"{field.DeprecatedAttribute.Value}\")]");
                            }
                            if (fd is StructDefinition)
                            {
                                builder.AppendLine(DisallowNullAttribute);
                            }
                            else if (fd is MessageDefinition)
                            {
                                builder.AppendLine(AllowNullAttribute);
                            }
                            var type = TypeName(field.Type, string.Empty);
                            var opt = fd is MessageDefinition && IsNullableType(field.Type) ? "?" : "";
                            var setOrInit = fd is StructDefinition { IsReadOnly: true } ? LanguageVersion == CSharpNine ? "init" : "private set" : "set";
                            builder.AppendLine($"public {type}{opt} {field.Name.ToPascalCase()} {{ get; {setOrInit}; }}");
                        }




                        builder.AppendLine();
                        // generate constructors
                        builder.AppendLine(FormatDocumentation(fd.Documentation, 0));
                        builder.AppendLine($"public {definition.ClassName()}() : base() {{ }}");
                        var nulllabilityAttribute = fd is StructDefinition ? DisallowNullAttribute : AllowNullAttribute;
                        var constructorArguments = string.Empty;
                        var constructorArgumentNames = string.Empty;
                        if (fd.Fields.Count > 0)
                        {

                            builder.AppendLine(FormatConstructorDocumentation(fd));
                            constructorArguments = string.Join(", ", fd.Fields.Select(f => $"{nulllabilityAttribute} {TypeName(f.Type)}{(fd is MessageDefinition && IsNullableType(f.Type) ? "?" : "")} {f.Name.ToCamelCase()}")).Trim();
                            constructorArgumentNames = string.Join(", ", fd.Fields.Select(f => f.Name.ToCamelCase())).Trim();
                            var propertyTuple = $"({string.Join(", ", fd.Fields.Select(f => f.Name.ToPascalCase())).Trim()})";
                            var copyTuple = $"({string.Join(", ", fd.Fields.Select(f => $"original{(fd is MessageDefinition && IsNullableType(f.Type) ? "?" : "")}.{f.Name.ToPascalCase()}")).Trim()})";
                            var argumentsTuple = $"({constructorArgumentNames})";
                            builder.AppendLine($"public {definition.ClassName()}({constructorArguments}) => {propertyTuple} = {argumentsTuple};");
                            builder.AppendLine($"public {definition.ClassName()}({nulllabilityAttribute} {definition.ClassName()}{(fd is MessageDefinition ? "?" : "")} original) => {propertyTuple} = {copyTuple};");

                            var destructorArguments = string.Join(", ", fd.Fields.Select(f => $"{nulllabilityAttribute} out {TypeName(f.Type)}{(fd is MessageDefinition && IsNullableType(f.Type) ? "?" : "")} {f.Name.ToCamelCase()}")).Trim();
                            builder.AppendLine($"public void Deconstruct({destructorArguments}) => {argumentsTuple} = {propertyTuple};");
                        }

                        builder.AppendLine().AppendLine(CompileGetByteCount(fd, false)).AppendLine();
                        builder.AppendLine().AppendLine(CompileGetByteCount(fd, true)).AppendLine();

                        if (fd is MessageDefinition)
                        {
                            builder.AppendLine("#nullable disable").AppendLine();
                        }

                        builder.AppendLine(CompileEncodeHelper(definition, "byte[]", "Encode"));
                        builder.AppendLine();
                        builder.AppendLine(CompileEncodeHelper(definition, ImmutableByteArrayType, "EncodeImmutably"));
                        builder.AppendLine();


                        builder.AppendLine("#region Static Decode Methods");
                        foreach (var bufferType in DecodeBufferTypes)
                        {
                            builder.AppendLine(CompileDecodeHelper(definition, bufferType));
                            builder.AppendLine();
                        }
                        builder.AppendLine("#endregion");


                        builder.AppendLine("#region Internal Use");
                        builder.AppendLine(Warning);
                        builder.AppendLine(HotPath);
                        builder.AppendLine(NonUserCodeAttribute);
                        builder.AppendLine(BrowsableAttribute);
                        builder.AppendLine($"internal static int __EncodeInto({PrefixNamespace(definition.ClassName())} record, ref {BebopWriter} writer) {{");
                        builder.Indent(indentStep);
                        builder.AppendLine("var before = writer.Length;");
                        builder.AppendLine(CompileEncode(fd));
                        builder.AppendLine("var after = writer.Length;");
                        builder.AppendLine("return after - before;");
                        builder.Dedent(indentStep);
                        builder.AppendLine("}");
                        builder.AppendLine();



                        builder.AppendLine();
                        builder.AppendLine(Warning);
                        builder.AppendLine(HotPath);
                        builder.AppendLine(NonUserCodeAttribute);
                        builder.AppendLine(BrowsableAttribute);
                        builder.AppendLine($"internal static {PrefixNamespace(definition.ClassName())} __DecodeFrom(ref {BebopReader} reader) {{");
                        builder.Indent(indentStep).AppendLine();
                        builder.AppendLine(CompileDecode(fd, false));
                        builder.Dedent(indentStep);
                        builder.AppendLine("}").AppendLine();
                        builder.AppendLine("#endregion");

                        builder.AppendLine("#region Equality");
                        builder.AppendLine(CompileIEquatableImpl(fd));
                        builder.AppendLine("#endregion");
                        builder.AppendLine();

                        builder.Dedent(indentStep);
                        builder.AppendLine("}");
                        builder.AppendLine("");
                    }
                    else if (definition is UnionDefinition ud)
                    {
                        CompileUnionFamily(builder, ud);
                    }
                }
                else if (definition is ConstDefinition cd)
                {
                    var constish = CanBeDeclaredConst(cd.Value.Type) ? "const" : "static readonly";
                    builder.AppendLine($"public {constish} {TypeName(cd.Value.Type)} {cd.Name} = {EmitLiteral(cd.Value)};");
                    builder.AppendLine("");
                }
                else
                {
                    throw new InvalidOperationException($"Unsupported definition {definition}");
                }

            }

            if (!string.IsNullOrWhiteSpace(Schema.Namespace))
            {
                builder.Dedent(indentStep);
                builder.AppendLine("}");
            }
            return builder.ToString();
        }

        #region Const
        private static string EscapeStringLiteral(string value)
        {
            // C# accepts \u0000 style escape sequences, so we can escape the string JSON-style.
            var options = new JsonSerializerOptions { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
            return JsonSerializer.Serialize(value, options);
        }

        private string EmitLiteral(Literal literal)
        {
            return literal switch
            {
                BoolLiteral bl => bl.Value ? "true" : "false",
                IntegerLiteral il => il.Value,
                FloatLiteral fl when fl.Value == "inf" => "double.PositiveInfinity",
                FloatLiteral fl when fl.Value == "-inf" => "double.NegativeInfinity",
                FloatLiteral fl when fl.Value == "nan" => "double.NaN",
                FloatLiteral fl => fl.Value,
                StringLiteral sl => EscapeStringLiteral(sl.Value),
                GuidLiteral gl => $"new global::System.Guid(\"{gl.Value}\")",
                _ => throw new ArgumentOutOfRangeException(literal.ToString()),
            };
        }

        private bool CanBeDeclaredConst(TypeBase type) =>
            type switch
            {
                ScalarType st when st.IsFloat || st.IsInteger => true,
                ScalarType { BaseType: BaseType.Bool or BaseType.String } => true,
                _ => false,
            };
        #endregion

        #region Message
        private string CompileEncodeMessage(MessageDefinition definition)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine("var pos = writer.ReserveRecordLength();");
            builder.AppendLine("var start = writer.Length;");
            foreach (var field in definition.Fields)
            {
                if (field.DeprecatedAttribute is not null)
                {
                    continue;
                }
                builder.AppendLine("");

                var isNullableType = IsNullableType(field.Type);
                var nullCheck = isNullableType && LanguageVersion == CSharpNine ? "is not null" : "!= null";
                builder.AppendLine($"if (record.{field.Name.ToPascalCase()} {nullCheck}) {{");
                builder.Indent(indentStep);
                builder.AppendLine($"writer.WriteByte({field.ConstantValue});");
                builder.AppendLine(isNullableType && NeedsValueAppend(field.Type)
                    ? $"{CompileEncodeField(field.Type, $"record.{field.Name.ToPascalCase()}.Value")}"
                    : $"{CompileEncodeField(field.Type, $"record.{field.Name.ToPascalCase()}")}");
                builder.Dedent(indentStep);
                builder.AppendLine("}");
            }
            builder.AppendLine("writer.WriteByte(0);");
            builder.AppendLine("var end = writer.Length;");
            builder.AppendLine("writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));");
            return builder.ToString();
        }

        /// <summary>
        ///     Generate the body of the <c>DecodeFrom</c> function for the given <see cref="MessageDefinition"/>,
        ///     given that its "kind" is Message.
        /// </summary>
        /// <param name="definition">The message definition to generate code for.</param>
        /// <param name="useGenerics"></param>
        /// <returns>The generated C# <c>DecodeFrom</c> function body.</returns>
        private string CompileDecodeMessage(MessageDefinition definition, bool useGenerics)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine($"var record = new {(useGenerics ? "T" : $"{PrefixNamespace(definition.Name.ToPascalCase())}")}();");
            builder.AppendLine("var length = reader.ReadRecordLength();");
            builder.AppendLine("var end = unchecked((int) (reader.Position + length));");
            builder.AppendLine("while (true) {");
            builder.Indent(indentStep);
            builder.AppendLine("switch (reader.ReadByte()) {");
            builder.Indent(indentStep);

            // 0 case: end of message
            builder.AppendLine("case 0:");
            builder.Indent(indentStep);
            builder.AppendLine("return record;");
            builder.Dedent(indentStep);

            // cases for fields
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"case {field.ConstantValue}:");
                builder.Indent(indentStep);
                builder.AppendLine($"{CompileDecodeField(field.Type, $"record.{field.Name.ToPascalCase()}")}");
                builder.AppendLine("break;");
                builder.Dedent(indentStep);
            }

            // default case: unknown, skip to end of message
            builder.AppendLine("default:");
            builder.Indent(indentStep);
            builder.AppendLine("reader.Position = end;");
            builder.AppendLine("return record;");
            builder.Dedent(indentStep);

            // end switch:
            builder.Dedent(indentStep);
            builder.AppendLine("}");

            // end while:
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            return builder.ToString();
        }

        #endregion

        #region Struct

        private string CompileEncodeStruct(StructDefinition definition)
        {
            var builder = new IndentedStringBuilder();
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"{CompileEncodeField(field.Type, $"record.{field.Name.ToPascalCase()}")}");
            }
            return builder.ToString();
        }

        private string CompileDecodeStruct(StructDefinition definition, bool useGenerics)
        {
            var builder = new IndentedStringBuilder();
            var i = 0;
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"{TypeName(field.Type)} field{i};");
                builder.AppendLine($"{CompileDecodeField(field.Type, $"field{i}")}");
                i++;
            }

            builder.AppendLine($"return new {(useGenerics ? "T" : PrefixNamespace($"{definition.Name.ToPascalCase()}"))} {{");
            builder.Indent(indentStep);
            i = 0;
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"{field.Name.ToPascalCase()} = field{i++},");
            }
            builder.Dedent(indentStep);
            builder.AppendLine("};");
            return builder.ToString();
        }

        #endregion

        #region Union

        private string CompileEncodeUnion(UnionDefinition definition)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine("var pos = writer.ReserveRecordLength();");
            builder.AppendLine("writer.WriteByte(record.Discriminator);");
            builder.AppendLine("var start = writer.Length;");
            builder.AppendLine("switch (record.Discriminator) {").Indent(indentStep);
            foreach (var branch in definition.Branches)
            {

                builder.AppendLine($"case {branch.Discriminator}: {PrefixNamespace(branch.Definition.Name.ToPascalCase())}.__EncodeInto(record.As{branch.Definition.ClassName()}, ref writer); break;");
            }
            builder.Dedent(indentStep).AppendLine("}");
            builder.AppendLine("var end = writer.Length;");
            builder.AppendLine("writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));");
            return builder.ToString();
        }

        private string CompileDecodeUnion(UnionDefinition definition)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine("var length = reader.ReadRecordLength();");
            builder.AppendLine("var end = unchecked((int) (reader.Position + length + 1));");
            builder.AppendLine("switch (reader.ReadByte()) {").Indent(indentStep);
            foreach (var branch in definition.Branches)
            {
                builder.AppendLine($"case {branch.Discriminator}:").Indent(4);
                builder.AppendLine($"return {PrefixNamespace(branch.Definition.Name.ToPascalCase())}.__DecodeFrom(ref reader);").Dedent(4);
            }
            builder.AppendLine("default:").Indent(4);
            builder.AppendLine("reader.Position = end;");
            builder.AppendLine("return null;").Dedent(4);
            builder.AppendLine("}");
            return builder.ToString();
        }

        /// <summary>
        /// Compiles the family of types necessary to support discriminated unions in C#
        /// </summary>
        private void CompileUnionFamily(IndentedStringBuilder builder, UnionDefinition ud)
        {
            var recordAttribute = "[global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Union)]";
            var genericPositionalArguments = string.Join(", ", ud.Branches.Select(b => $"T{b.GenericIndex()}")).Trim();
            var genericTypeArguments = string.Join(", ", ud.Branches.Select(b => $"{PrefixNamespace(b.Definition.ClassName())}")).Trim();
            var genericConstraints = string.Join(' ', ud.Branches.Select(b => $"where T{b.GenericIndex()}: {PrefixNamespace(b.Definition.ClassName())}")).Trim();

            var structName = $"{ud.ClassName()}Union";

            var nullCheck = LanguageVersion == CSharpNine ? "is null" : "== null";
            var notNullCheck = LanguageVersion == CSharpNine ? "is not null" : "!= null";
            var isCheck = LanguageVersion == CSharpNine ? "is" : "==";

            void CompileValueProperty()
            {
                builder.AppendLine($"public {BebopRecord} Value => _discriminator switch {{").Indent(4);
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"{branch.Discriminator} => _value{branch.GenericIndex()},");
                }
                builder.AppendLine($"_ => throw new {BebopException}()").Dedent(4).AppendLine("};").AppendLine();
                builder.AppendLine("public byte Discriminator => _discriminator;").AppendLine();
            }

            void CompileIsAs()
            {
                builder.AppendLine("#region IsAs");
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"public bool Is{branch.Definition.ClassName()} => _discriminator {isCheck} {branch.Discriminator};");
                    builder.AppendLine(
                        $"public T{branch.GenericIndex()} As{branch.Definition.ClassName()} => _discriminator {isCheck} {branch.Discriminator} ? _value{branch.GenericIndex()} : throw new global::System.NotImplementedException($\"Cannot return as {branch.Definition.ClassName()} as result is T{branch.GenericIndex()}\");").AppendLine();
                }
                builder.AppendLine("#endregion");
            }

            void CompileSwitch()
            {
                var switchParams = string.Join(", ", ud.Branches.Select(b => $"global::System.Action<T{b.GenericIndex()}> f{b.GenericIndex()}")).Trim();
                builder.AppendLine($"public void Switch({switchParams}) {{");
                foreach (var branch in ud.Branches)
                {
                    builder.Indent(4).AppendLine($"if (_discriminator {isCheck} {branch.Discriminator} && f{branch.GenericIndex()} {notNullCheck}) {{");
                    builder.Indent(2).AppendLine($"f{branch.GenericIndex()}(_value{branch.GenericIndex()});").AppendLine("return;");
                    builder.Dedent(2).AppendLine("}").Dedent(4);
                }
                builder.Indent(4).AppendLine($"throw new {BebopException}();").Dedent(4).AppendLine("}").AppendLine();
            }

            void CompileMatch()
            {
                var matchParams = string.Join(", ", ud.Branches.Select(b => $"global::System.Func<T{b.GenericIndex()}, TResult> f{b.GenericIndex()}")).Trim();
                builder.AppendLine($"public TResult Match<TResult>({matchParams}) => _discriminator switch {{").Indent(4);
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"{branch.Discriminator} when f{branch.GenericIndex()} {notNullCheck} => f{branch.GenericIndex()}(_value{branch.GenericIndex()}),");
                }
                builder.AppendLine($"_ => throw new {BebopException}()").Dedent(4).AppendLine("};").AppendLine();
            }

            void CompileHashCode()
            {
                builder.AppendLine("public override int GetHashCode() => (_discriminator switch {").Indent(4);
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"{branch.Discriminator} => _value{branch.GenericIndex()}?.GetHashCode() ?? 0,");
                }
                builder.AppendLine("_ => 0").Dedent(4);
                builder.AppendLine("} * 397) ^ _discriminator;").AppendLine();
            }

            void CompileEquals(bool isClass)
            {
                builder.AppendLine("#region Equality");
                builder.AppendLine($"private bool Equals({PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}> other) => _discriminator == other.Discriminator && _discriminator switch {{").Indent(4);
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"{branch.Discriminator} => Equals(_value{branch.GenericIndex()}, other._value{branch.GenericIndex()}),");
                }
                builder.AppendLine("_ => false");
                builder.Dedent(4).AppendLine("};").AppendLine();

                builder.AppendLine("public override bool Equals(object other) {").Indent(4);
                builder.AppendLine("if (ReferenceEquals(null, other)) {").Indent(indentStep).AppendLine("return false;").Dedent(indentStep).AppendLine("}");
                if (isClass)
                {
                    builder.AppendLine("if (ReferenceEquals(this, other)) {").Indent(indentStep).AppendLine("return true;").Dedent(indentStep).AppendLine("}");
                }
                if (LanguageVersion == CSharpNine)
                {
                    builder.AppendLine($"return other is {PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}> o && Equals(o);").Dedent(4).AppendLine("}");
                }
                else
                {
                    builder.AppendLine($"return other.GetType() == typeof({PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}>) && Equals(({PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}>) other);").Dedent(4).AppendLine("}");
                }
                
                builder.AppendLine();
                if (isClass)
                {
                    builder.AppendLine($"public static bool operator ==({PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}> left, {PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}> right) => Equals(left, right);");
                    builder.AppendLine($"public static bool operator !=({PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}> left, {PrefixNamespace(ud.BaseClassName())}<{genericPositionalArguments}> right) => !Equals(left, right);");
                }
                CompileHashCode();
                builder.AppendLine("#endregion");
            }
            // Compiles a read-only struct which holds our union. 
            void CompileUnionStruct()
            {
                builder.AppendLine("/// <inheritdoc />");
                builder.AppendLine(GeneratedAttribute);
                builder.AppendLine($"public readonly struct {structName}<{genericPositionalArguments}> {genericConstraints} {{").Indent(indentStep).AppendLine();
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"internal readonly T{branch.GenericIndex()} _value{branch.GenericIndex()};");
                }
                builder.AppendLine("private readonly byte _discriminator;").AppendLine();

                var constructorArgs = string.Join(", ", ud.Branches.Select(b => $"T{b.GenericIndex()} value{b.GenericIndex()} = default")).Trim();
                builder.AppendLine($"private {structName}(byte discriminator, {constructorArgs}) {{");
                builder.Indent(4).AppendLine("_discriminator = discriminator;");
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"_value{branch.GenericIndex()} = value{branch.GenericIndex()};");
                }
                builder.Dedent(4).AppendLine("}").AppendLine();
                CompileValueProperty();
                CompileIsAs();
                builder.AppendLine("#region Implicit Overrides");
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine(
                        $"public static implicit operator {PrefixNamespace(structName)}<{genericPositionalArguments}>(T{branch.GenericIndex()} t) => new  {PrefixNamespace(structName)}<{genericPositionalArguments}>({branch.Discriminator}, value{branch.GenericIndex()}: t);");
                    builder.AppendLine($"public static {PrefixNamespace(structName)}<{genericPositionalArguments}> From{branch.BaseClassName()}(T{branch.GenericIndex()} input) => input;").AppendLine();
                }
                builder.AppendLine("#endregion");
                builder.AppendLine();
                CompileSwitch();
                CompileMatch();
                CompileEquals(false);
                builder.Dedent(indentStep).AppendLine("}").AppendLine();
            }

            void CompileUnionBaseClass()
            {

                builder.AppendLine($"public abstract class {ud.BaseClassName()}<{genericPositionalArguments}> : {BebopRecord} {genericConstraints} {{").Indent(indentStep);

                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"internal readonly T{branch.GenericIndex()} _value{branch.GenericIndex()};");
                }
                builder.AppendLine("private readonly byte _discriminator;").AppendLine();
                builder.AppendLine($"protected private {ud.BaseClassName()}() {{ }}");
                builder.AppendLine($"protected {ud.BaseClassName()}({PrefixNamespace(structName)}<{genericPositionalArguments}> input) {{");
                builder.Indent(4).AppendLine("_discriminator = input.Discriminator;");
                builder.AppendLine("switch (_discriminator) {").Indent(indentStep);
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"case {branch.Discriminator}: _value{branch.GenericIndex()} = input.As{branch.Definition.ClassName()}; break;");
                }
                builder.AppendLine($"default: throw new {BebopException}();").Dedent(indentStep).AppendLine("}");
                builder.Dedent(4).AppendLine("}").AppendLine();
                CompileValueProperty();
                CompileIsAs();
                CompileSwitch();
                CompileMatch();
                CompileEquals(true);
                builder.Dedent(indentStep).AppendLine("}").AppendLine();
            }


            // Compiles the class that is responsible for decoding / encoding and should be used.
            void CompileUnionConcreteClass()
            {

                builder.AppendLine("/// <inheritdoc />");
                builder.AppendLine(GeneratedAttribute);
                builder.AppendLine(recordAttribute);
                builder.AppendLine($"public partial class {ud.ClassName()} : {PrefixNamespace(ud.BaseClassName())}<{genericTypeArguments}> {{").Indent(indentStep).AppendLine();
                if (ud.OpcodeAttribute is { Value: not null })
                {
                    builder.AppendLine($"public const uint OpCode = {ud.OpcodeAttribute.Value};");
                }

                builder.AppendLine("/// <inheritdoc />");
                builder.AppendLine($"public sealed override int MaxByteCount => GetMaxByteCount();");
                builder.AppendLine("/// <inheritdoc />");
                builder.AppendLine($"public sealed override int ByteCount => GetByteCount();");
                builder.AppendLine();
                builder.AppendLine($"protected private {ud.ClassName()}(): base() {{ }}");
                builder.AppendLine($"private {ud.ClassName()}({PrefixNamespace(structName)}<{genericTypeArguments}> _) : base(_) {{ }}").AppendLine();

                builder.AppendLine(CompileEncodeHelper(ud, "byte[]", "Encode"));
                builder.AppendLine();
                builder.AppendLine(CompileEncodeHelper(ud, ImmutableByteArrayType, "EncodeImmutably")).AppendLine();

                builder.AppendLine(CompileGetByteCount(ud, false)).AppendLine();
                builder.AppendLine(CompileGetByteCount(ud, true)).AppendLine();


                builder.AppendLine("#region Static Decode Methods");
                foreach (var bufferType in DecodeBufferTypes)
                {
                    builder.AppendLine(CompileDecodeHelper(ud, bufferType));
                    builder.AppendLine();
                }
                builder.AppendLine("#endregion");
                builder.AppendLine("#region Implicit Overrides");
                foreach (var branch in ud.Branches)
                {
                    if (LanguageVersion == CSharpNine)
                    {
                        builder.AppendLine($"public static implicit operator {PrefixNamespace(ud.ClassName())}({PrefixNamespace(branch.Definition.ClassName())} _) => new (_);");
                        builder.AppendLine($"public static {PrefixNamespace(ud.ClassName())} From{branch.Definition.ClassName()}({PrefixNamespace(branch.Definition.ClassName())} input) => new (input);").AppendLine();
                    } else
                    {
                        builder.AppendLine($"public static implicit operator {PrefixNamespace(ud.ClassName())}({PrefixNamespace(branch.Definition.ClassName())} _) => new {PrefixNamespace(ud.ClassName())}(_);");
                        builder.AppendLine($"public static {PrefixNamespace(ud.ClassName())} From{branch.Definition.ClassName()}({PrefixNamespace(branch.Definition.ClassName())} input) => new {PrefixNamespace(ud.ClassName())}(input);").AppendLine();
                    }
                   
                }
                builder.AppendLine("#endregion");

                builder.AppendLine("#region Internal Use");
                builder.AppendLine(HotPath);
                builder.AppendLine($"internal static void __EncodeInto({PrefixNamespace(ud.ClassName())} record, ref {BebopWriter} writer) {{");
                builder.Indent(indentStep);
                builder.AppendLine(CompileEncode(ud));
                builder.Dedent(indentStep);
                builder.AppendLine("}").AppendLine();

                builder.AppendLine(HotPath);
                builder.AppendLine($"internal static {PrefixNamespace(ud.ClassName())} __DecodeFrom(ref {BebopReader} reader) {{").Indent(indentStep).AppendLine();
                builder.AppendLine(CompileDecode(ud, false));
                builder.Dedent(indentStep);
                builder.AppendLine("}").AppendLine();
                builder.AppendLine("#endregion");





                builder.Dedent(indentStep).AppendLine("}").AppendLine();
            }

            CompileUnionBaseClass();
            CompileUnionConcreteClass();
            CompileUnionStruct();
        }

        #endregion

        #region Root Compilers

        /// <summary>
        ///     Generate the body of the <c>EncodeTo</c> function for the given <see cref="Definition"/>.
        /// </summary>
        /// <param name="definition">The definition to generate code for.</param>
        /// <returns>The generated C# <c>EncodeTo</c> function body.</returns>
        public string CompileEncode(Definition definition)
        {
            return definition switch
            {
                MessageDefinition d => CompileEncodeMessage(d),
                StructDefinition d => CompileEncodeStruct(d),
                UnionDefinition d => CompileEncodeUnion(d),
                _ => throw new InvalidOperationException($"invalid CompileEncode kind: {definition}")
            };
        }


        /// <summary>
        ///     Generate the body of the <c>DecodeFrom</c> function for the given <see cref="Definition"/>.
        /// </summary>
        /// <param name="definition">The definition to generate code for.</param>
        /// <param name="useGenerics"></param>
        /// <returns>The generated C# <c>DecodeFrom</c> function body.</returns>
        public string CompileDecode(Definition definition, bool useGenerics)
        {
            return definition switch
            {
                MessageDefinition d => CompileDecodeMessage(d, useGenerics),
                StructDefinition d => CompileDecodeStruct(d, useGenerics),
                UnionDefinition d => CompileDecodeUnion(d),
                _ => throw new InvalidOperationException($"invalid CompileDecode kind: {definition}")
            };
        }

        #endregion

        #region Auxiliary Compilers

        /// <summary>
        ///     Generates code to implement <see cref="IEquatable{T}"/> in the base defined type.
        /// </summary>
        /// <param name="definition"></param>
        /// <returns></returns>
        private string CompileIEquatableImpl(FieldsDefinition definition)
        {

            var builder = new IndentedStringBuilder();
            builder.AppendLine($"public bool Equals({PrefixNamespace(definition.ClassName())} other) {{");
            builder.Indent(indentStep);
            builder.AppendLine("if (ReferenceEquals(null, other)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return false;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine("if (ReferenceEquals(this, other)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return true;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");

            if (definition is not { Fields: { Count: 0 } })
            {
                var returnStatement = new StringBuilder("return");
                for (var i = 0; i < definition.Fields.Count; i++)
                {
                    var field = definition.Fields.ElementAt(i);
                    var fieldName = field.Name.ToPascalCase();
                    var and = $"{(i == definition.Fields.Count - 1 ? "" : " &&")}";
                    var isNullableType = IsNullableType(field.Type);
                    var nullCheck = isNullableType && LanguageVersion == CSharpNine ? "is null" : "== null";
                    var notNullCheck = isNullableType && LanguageVersion == CSharpNine ? "is not null" : "!= null";
                    // for collections we try to be extra safe to avoid throwing exceptions.
                    returnStatement.Append(field.IsCollection()
                        ? $" ({fieldName} {nullCheck} ? other.{fieldName} {nullCheck} : other.{fieldName} {notNullCheck} && global::System.Linq.Enumerable.SequenceEqual({fieldName}, other.{fieldName})){and}"
                        : $" {fieldName} == other.{fieldName}{and}");
                }
                returnStatement.Append(";");
                builder.AppendLine(returnStatement.ToString());
            }
            else
            {
                // if the definition has no properties then we can just return true.
                builder.AppendLine("return true;");
            }

            builder.Dedent(indentStep);
            builder.AppendLine("}");

            builder.AppendLine();

            builder.AppendLine("public override bool Equals(object obj) {");
            builder.Indent(indentStep);
            builder.AppendLine("if (ReferenceEquals(null, obj)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return false;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine("if (ReferenceEquals(this, obj)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return true;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            if (LanguageVersion == CSharpNine)
            {

                builder.AppendLine($"if (obj is not {PrefixNamespace(definition.ClassName())} baseType) {{");
                builder.Indent(indentStep);
                builder.AppendLine("return false;");
                builder.Dedent(indentStep);
                builder.AppendLine("}");

                builder.AppendLine("return Equals(baseType);");
            }
            else
            {
                builder.AppendLine($"if (obj.GetType() != typeof({PrefixNamespace(definition.ClassName())})) {{");
                builder.Indent(indentStep);
                builder.AppendLine("return false;");
                builder.Dedent(indentStep);
                builder.AppendLine("}");
                builder.AppendLine($"return Equals(({PrefixNamespace(definition.ClassName())}) obj);");
            }
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();
            builder.AppendLine("public override int GetHashCode() {");
            builder.Indent(indentStep);
            builder.AppendLine("int hash = 1;");
            for (var i = 0; i < definition.Fields.Count; i++)
            {
                var field = definition.Fields.ElementAt(i);
                var fieldName = field.Name.ToPascalCase();
                if (definition is MessageDefinition)
                {
                    var isNullableType = IsNullableType(field.Type);
                    var nullCheck = isNullableType && LanguageVersion == CSharpNine ? "is not null" : "!= null";
                    var value = isNullableType && NeedsValueAppend(field.Type) && definition is MessageDefinition
                        ? $"{fieldName}.Value.GetHashCode();"
                        : $"{fieldName}.GetHashCode();";
                    builder.AppendLine($"if ({fieldName} {nullCheck}) hash ^= {value}");
                }
                else
                {
                    builder.AppendLine($"hash ^= {fieldName}.GetHashCode();");
                }
            }
            builder.AppendLine("return hash;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();
            builder.AppendLine($"public static bool operator ==({PrefixNamespace(definition.ClassName())} left, {PrefixNamespace(definition.ClassName())} right) => Equals(left, right);");
            builder.AppendLine($"public static bool operator !=({PrefixNamespace(definition.ClassName())} left, {PrefixNamespace(definition.ClassName())}  right) => !Equals(left, right);");
            return builder.ToString();
        }

        private string CompileGetByteCount(TopLevelDefinition definition, bool isAccurate)
        {
            var builder = new IndentedStringBuilder();
            var propertyName = isAccurate ? "ByteCount" : "MaxByteCount";
            var summary = isAccurate ? "Calculates the number of bytes produced by encoding the current record." : "Calculates the maximum number of bytes produced by encoding the current record.";
            builder.AppendLine($"/// <summary>{summary}</summary>");
            builder.AppendLine(HotPath);
            builder.AppendLine($"private protected int {(isAccurate ? "GetByteCount" : "GetMaxByteCount")}() {{").Indent(indentStep);
            builder.AppendLine("int byteCount = 0;");


            if (definition is FieldsDefinition fd)
            {
                if (fd is MessageDefinition)
                {
                    builder.AppendLine($"byteCount += {fd.MinimalEncodedSize(Schema)};");
                }
                foreach (var field in fd.Fields)
                {
                    if (fd is MessageDefinition)
                    {
                        var isNullableType = IsNullableType(field.Type);
                        var notNullCheck = isNullableType && LanguageVersion == CSharpNine ? "is not null" : "!= null";
                        builder.AppendLine($"if ({field.Name.ToPascalCase()} {notNullCheck}) {{").Indent(indentStep);
                        // the size of the index byte
                        builder.AppendLine("byteCount += sizeof(byte);");
                    }
                    builder.AppendLine(CompileSizeAssignment(field.Type, field.Name.ToPascalCase(), isAccurate));

                    if (fd is MessageDefinition)
                    {
                        builder.Dedent(indentStep).AppendLine("}");
                    }
                }

            }
            else if (definition is UnionDefinition ud)
            {

                builder.AppendLine("byteCount += sizeof(uint) + sizeof(byte) + Discriminator switch {").Indent(4);
                foreach (var branch in ud.Branches)
                {
                    builder.AppendLine($"{branch.Discriminator} => As{branch.Definition.ClassName()}.{propertyName},");
                }
                builder.AppendLine($"_ => throw new {BebopException}()").Dedent(4).AppendLine("};");

            }

            builder.AppendLine("return byteCount;");
            builder.Dedent(indentStep).AppendLine("}");

            return builder.ToString();
        }

        private string CompileSizeAssignment(TypeBase type, string target, bool isAccurate, int depth = 0, int indentDepth = 0)
        {
            var outerVariable = "byteCount +=";
            var tab = new string(' ', indentStep);
            var nl = "\n" + new string(' ', indentDepth * indentStep);
            var i = GeneratorUtils.LoopVariable(depth);
            return type switch
            {
                ArrayType at when at.MemberType.IsFixedScalar() || at.MemberType.IsEnum(Schema) => $"{outerVariable} sizeof(uint) + {target}.Length * {at.MemberType.MinimalEncodedSize(Schema)};",
                ArrayType at =>
                    "{" + nl +
                    $"{tab}var length{depth} = unchecked((uint){target}.Length);" + nl +
                    $"{tab}{outerVariable} sizeof(uint);" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{CompileSizeAssignment(at.MemberType, $"{target}[{i}]", isAccurate, depth + 1, indentDepth + 2)}" + nl +
                    $"{tab}}}" + nl +
                    "}",
                MapType mt when (mt.KeyType.IsFixedScalar() && mt.ValueType.IsEnum(Schema)) || (mt.KeyType.IsFixedScalar() && mt.ValueType.IsFixedScalar()) => $"{outerVariable} sizeof(uint) + ({target}.Count * {mt.KeyType.MinimalEncodedSize(Schema) + mt.ValueType.MinimalEncodedSize(Schema)});",
                MapType mt =>
                    $"{outerVariable} sizeof(uint);" + nl +
                    $"foreach (var kv{depth} in {target}) {{" + nl +
                    $"{tab}{CompileSizeAssignment(mt.KeyType, $"kv{depth}.Key", isAccurate, depth + 1, indentDepth + 1)}" + nl +
                    $"{tab}{CompileSizeAssignment(mt.ValueType, $"kv{depth}.Value", isAccurate, depth + 1, indentDepth + 1)}" + nl +
                    "}",
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => $"{outerVariable} sizeof(bool);",
                    BaseType.Byte => $"{outerVariable} sizeof(byte);",
                    BaseType.UInt32 => $"{outerVariable} sizeof(uint);",
                    BaseType.Int32 => $"{outerVariable} sizeof(int);",
                    BaseType.Float32 => $"{outerVariable} sizeof(float);",
                    BaseType.Float64 => $"{outerVariable} sizeof(double);",
                    BaseType.String => $"{outerVariable} sizeof(uint) + {(isAccurate ? StringGetByteCount : StringGetMaxByteCount)}({(isAccurate ? target : $"{target}.Length")});",
                    BaseType.Guid => $"{outerVariable} {st.MinimalEncodedSize(Schema)};",
                    BaseType.UInt16 => $"{outerVariable} sizeof(ushort);",
                    BaseType.Int16 => $"{outerVariable} sizeof(short);",
                    BaseType.UInt64 => $"{outerVariable} sizeof(ulong);",
                    BaseType.Int64 => $"{outerVariable} sizeof(long);",
                    BaseType.Date => $"{outerVariable} {st.MinimalEncodedSize(Schema)};",
                    _ => throw new ArgumentOutOfRangeException()
                },
                DefinedType dt when dt.IsEnum(Schema) =>
                    $"{outerVariable} sizeof(uint);",
                DefinedType => $"{outerVariable} {target}.{(isAccurate ? "ByteCount" : "MaxByteCount")};",
                _ => throw new InvalidOperationException($"CompileSizeAssignment: {type}")
            };
        }

        private string CompileEncodeField(TypeBase type, string target, int depth = 0, int indentDepth = 0)
        {
            var tab = new string(' ', indentStep);
            var nl = "\n" + new string(' ', indentDepth * indentStep);
            var i = GeneratorUtils.LoopVariable(depth);
            return type switch
            {
                ArrayType at when at.IsBytes() => $"writer.WriteBytes({target});",
                ArrayType at when at.IsFloat32s() => $"writer.WriteFloat32S({target});",
                ArrayType at when at.IsFloat64s() => $"writer.WriteFloat64S({target});",
                ArrayType at =>
                    "{" + nl +
                    $"{tab}var length{depth} = unchecked((uint){target}.Length);" + nl +
                    $"{tab}writer.WriteUInt32(length{depth});" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{CompileEncodeField(at.MemberType, $"{target}[{i}]", depth + 1, indentDepth + 2)}" + nl +
                    $"{tab}}}" + nl +
                    "}",
                MapType mt =>
                    $"writer.WriteUInt32(unchecked((uint){target}.Count));" + nl +
                    $"foreach (var kv{depth} in {target}) {{" + nl +
                    $"{tab}{CompileEncodeField(mt.KeyType, $"kv{depth}.Key", depth + 1, indentDepth + 1)}" + nl +
                    $"{tab}{CompileEncodeField(mt.ValueType, $"kv{depth}.Value", depth + 1, indentDepth + 1)}" + nl +
                    "}",
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => $"writer.WriteByte({target});",
                    BaseType.Byte => $"writer.WriteByte({target});",
                    BaseType.UInt32 => $"writer.WriteUInt32({target});",
                    BaseType.Int32 => $"writer.WriteInt32({target});",
                    BaseType.Float32 => $"writer.WriteFloat32({target});",
                    BaseType.Float64 => $"writer.WriteFloat64({target});",
                    BaseType.String => $"writer.WriteString({target});",
                    BaseType.Guid => $"writer.WriteGuid({target});",
                    BaseType.UInt16 => $"writer.WriteUInt16({target});",
                    BaseType.Int16 => $"writer.WriteInt16({target});",
                    BaseType.UInt64 => $"writer.WriteUInt64({target});",
                    BaseType.Int64 => $"writer.WriteInt64({target});",
                    BaseType.Date => $"writer.WriteDate({target});",
                    _ => throw new ArgumentOutOfRangeException()
                },
                DefinedType dt when dt.IsEnum(Schema) =>
                    $"writer.WriteEnum<{PrefixNamespace(dt.Name.ToPascalCase())}>({target});",
                DefinedType dt =>
                    $"{PrefixNamespace(dt.Name.ToPascalCase())}.__EncodeInto({target}, ref writer);",
                _ => throw new InvalidOperationException($"CompileEncodeField: {type}")
            };
        }


        private string CompileDecodeField(TypeBase type, string target, int depth = 0)
        {
            var tab = new string(' ', indentStep);
            var nl = "\n" + new string(' ', depth * 2 * indentStep);
            var i = GeneratorUtils.LoopVariable(depth);
            return type switch
            {
                ArrayType at when at.IsBytes() => $"{target} = reader.ReadBytes();",
                ArrayType at =>
                    "{" + nl +
                    $"{tab}var length{depth} = unchecked((int)reader.ReadUInt32());" + nl +
                    $"{tab}{target} = new {TypeName(at, $"length{depth}")};" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{TypeName(at.MemberType)} x{depth};" + nl +
                    $"{tab}{tab}{CompileDecodeField(at.MemberType, $"x{depth}", depth + 1)}" + nl +
                    $"{tab}{tab}{target}[{i}] = x{depth};" + nl +
                    $"{tab}}}" + nl +
                    "}",
                MapType mt =>
                    "{" + nl +
                    $"{tab}var length{depth} = unchecked((int)reader.ReadUInt32());" + nl +
                    $"{tab}{target} = new {TypeName(mt)}(length{depth});" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{TypeName(mt.KeyType)} k{depth};" + nl +
                    $"{tab}{tab}{TypeName(mt.ValueType)} v{depth};" + nl +
                    $"{tab}{tab}{CompileDecodeField(mt.KeyType, $"k{depth}", depth + 1)}" + nl +
                    $"{tab}{tab}{CompileDecodeField(mt.ValueType, $"v{depth}", depth + 1)}" + nl +
                    $"{tab}{tab}{target}.Add(k{depth}, v{depth});" + nl +
                    $"{tab}}}" + nl +
                    "}",
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => $"{target} = reader.ReadByte() != 0;",
                    BaseType.Byte => $"{target} = reader.ReadByte();",
                    BaseType.UInt32 => $"{target} = reader.ReadUInt32();",
                    BaseType.Int32 => $"{target} = reader.ReadInt32();",
                    BaseType.Float32 => $"{target} = reader.ReadFloat32();",
                    BaseType.String => $"{target} = reader.ReadString();",
                    BaseType.Guid => $"{target} = reader.ReadGuid();",
                    BaseType.UInt16 => $"{target} = reader.ReadUInt16();",
                    BaseType.Int16 => $"{target} = reader.ReadInt16();",
                    BaseType.UInt64 => $"{target} = reader.ReadUInt64();",
                    BaseType.Int64 => $"{target} = reader.ReadInt64();",
                    BaseType.Float64 => $"{target} = reader.ReadFloat64();",
                    BaseType.Date => $"{target} = reader.ReadDate();",
                    _ => throw new ArgumentOutOfRangeException()
                },
                DefinedType dt when Schema.Definitions[dt.Name] is EnumDefinition =>
                    $"{target} = reader.ReadEnum<{PrefixNamespace(dt.Name.ToPascalCase())}>();",
                DefinedType dt =>
                    $"{target} = {PrefixNamespace(dt.Name.ToPascalCase())}.__DecodeFrom(ref reader);",
                _ => throw new InvalidOperationException($"CompileDecodeField: {type}")
            };
        }

        /// <summary>
        ///     Generates the body of various helper methods to encode the given <see cref="Definition"/>
        /// </summary>
        /// <param name="definition"></param>
        /// <param name="bufferType"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        public string CompileEncodeHelper(Definition definition, string bufferType, string methodName)
        {
            var returnMethod = bufferType.Equals(ImmutableByteArrayType) ? "ToImmutableArray" : "ToArray";
            var builder = new IndentedStringBuilder();

            builder.AppendLine(HotPath);
            builder.AppendLine($"public sealed override {bufferType} {methodName}() {{");
            builder.Indent(indentStep);
            builder.AppendLine($"var writer = {BebopWriter}.Create();");
            builder.AppendLine("__EncodeInto(this, ref writer);");
            builder.AppendLine($"return writer.{returnMethod}();");
            builder.Dedent(indentStep);
            builder.AppendLine("}");

            builder.AppendLine(HotPath);
            builder.AppendLine($"public static {bufferType} {methodName}({PrefixNamespace(definition.ClassName())} record) {{");
            builder.Indent(indentStep);
            builder.AppendLine($"var writer = {BebopWriter}.Create();");
            builder.AppendLine("__EncodeInto(record, ref writer);");
            builder.AppendLine($"return writer.{returnMethod}();");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine("");

            return builder.ToString();
        }

        /// <summary>
        ///     Generates the body of various helper methods to decode the given <see cref="Definition"/>
        /// </summary>
        /// <param name="definition"></param>
        /// <param name="bufferType"></param>
        /// <returns></returns>
        public string CompileDecodeHelper(Definition definition, string bufferType)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine(HotPath);
            builder.AppendLine($"public static {PrefixNamespace(definition.ClassName())} Decode({bufferType} record) {{");
            builder.Indent(indentStep);
            builder.AppendLine($"var reader = {BebopReader}.From(record);");
            builder.AppendLine("return __DecodeFrom(ref reader);");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();

            return builder.ToString();
        }

        #endregion

        #region Helpers


        private static bool IsNullableType(TypeBase type)
        {
            return type switch
            {
                DefinedType => true,
                ArrayType { MemberType: ScalarType { BaseType: BaseType.Byte } } => false,
                ArrayType => true,
                MapType => true,
                ScalarType => true,
                _ => throw new InvalidOperationException($"CompileEncodeField: {type}")
            };
        }
        private bool NeedsValueAppend(TypeBase type)
        {
            return type switch
            {
                ScalarType { BaseType: BaseType.String } => false,
                DefinedType dt when dt.IsEnum(Schema) => true,
                DefinedType => false,
                ScalarType => true,
                _ => false
            };
        }

        private string PrefixNamespace(string definitionName)
        {
            var nameSpace = string.IsNullOrWhiteSpace(Schema.Namespace) ? string.Empty : $"global::{Schema.Namespace.ToPascalCase()}.";
            return $"{nameSpace}{definitionName}";
        }

        private string FormatConstructorDocumentation(FieldsDefinition fieldsDefinition)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine("/// <summary>");
            foreach (var line in fieldsDefinition.Documentation.GetLines())
            {
                builder.AppendLine($"/// <para>{line}</para>");
            }
            builder.AppendLine("/// </summary>");
            foreach (var field in fieldsDefinition.Fields)
            {
                builder.AppendLine($"/// <param name=\"{field.Name.ToCamelCase()}\">");
                foreach (var line in field.Documentation.GetLines())
                {
                    builder.AppendLine($"/// <para>{line}</para>");
                }
                builder.AppendLine($"/// </param>");
            }
            return builder.ToString();
        }

        private string FormatDocumentation(string documentation, int spaces)
        {
            var builder = new IndentedStringBuilder(spaces);
            builder.AppendLine("/// <summary>");
            foreach (var line in documentation.GetLines())
            {
                builder.AppendLine($"/// <para>{line}</para>");
            }
            builder.AppendLine("/// </summary>");
            return builder.ToString();
        }

        /// <summary>
        ///     Generate a C# type name for the given <see cref="TypeBase"/>.
        /// </summary>
        /// <param name="type">The field type to generate code for.</param>
        /// <param name="arraySizeVar">A variable name that will be formatted into the array initializer</param>
        /// <returns>The C# type name.</returns>
        private string TypeName(in TypeBase type, string arraySizeVar = "")
        {
            return type switch
            {
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => "bool",
                    BaseType.Byte => "byte",
                    BaseType.UInt32 => "uint",
                    BaseType.Int32 => "int",
                    BaseType.Float32 => "float",
                    BaseType.Float64 => "double",
                    BaseType.String => "string",
                    BaseType.Guid => "global::System.Guid",
                    BaseType.UInt16 => "ushort",
                    BaseType.Int16 => "short",
                    BaseType.UInt64 => "ulong",
                    BaseType.Int64 => "long",
                    BaseType.Date => "global::System.DateTime",
                    _ => throw new ArgumentOutOfRangeException(st.BaseType.ToString())
                },
                ArrayType { MemberType: ScalarType { BaseType: BaseType.Byte } } at =>
                    $"{ImmutableArrayType}<{TypeName(at.MemberType)}>",
                ArrayType at =>
                    $"{(at.MemberType is ArrayType ? $"{TypeName(at.MemberType, arraySizeVar)}[]" : $"{TypeName(at.MemberType)}[{arraySizeVar}]")}",
                MapType mt =>
                    $"global::System.Collections.Generic.Dictionary<{TypeName(mt.KeyType)}, {TypeName(mt.ValueType)}>",
                DefinedType dt => PrefixNamespace($"{dt.Name.ToPascalCase()}"),
                _ => throw new InvalidOperationException($"GetTypeName: {type}")
            };
        }


        public override void WriteAuxiliaryFiles(string outputPath)
        {
        }

        #endregion

        #region Consts



        private const int indentStep = 2;
        private const string DisallowNullAttribute = "[global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]";
        private const string AllowNullAttribute = "[global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]";
        private const string HotPath = "[global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]";
        private static readonly string GeneratedAttribute = $"[global::System.CodeDom.Compiler.GeneratedCode(\"{ReservedWords.CompilerName}\", \"{VersionInfo.Informational}\")]";
        private const string Warning = "/// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>";
        private const string NonUserCodeAttribute = "[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]";
        private const string BrowsableAttribute = "[global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]";
        private const string BebopWriter = "global::Bebop.Runtime.BebopWriter";
        private const string BebopReader = "global::Bebop.Runtime.BebopReader";
        private const string BebopException = "global::Bebop.Exceptions.BebopRuntimeException";
        private const string ImmutableArrayType = "global::System.Collections.Immutable.ImmutableArray";
        private const string ImmutableByteArrayType = "global::System.Collections.Immutable.ImmutableArray<byte>";
        private const string StringGetByteCount = "global::System.Text.Encoding.UTF8.GetByteCount";
        private const string StringGetMaxByteCount = "global::System.Text.Encoding.UTF8.GetMaxByteCount";
        private const string BebopRecord = "global::Bebop.Runtime.BaseBebopRecord";

        private static readonly string[] DecodeBufferTypes = { "byte[]", "global::System.ReadOnlySpan<byte>", "global::System.ReadOnlyMemory<byte>", "global::System.ArraySegment<byte>", ImmutableByteArrayType };
        /// <summary>
        /// C# 9.0 is supported only on .NET 5 and newer versions.
        /// </summary>
        private static readonly Version CSharpNine = new Version("9.0");
        /// <summary>
        /// C# 8.0 is only supported on platforms that implement .NET Standard 2.1.
        /// </summary>
        /// <remarks>
        /// To compile C# source code in a Unity Project, use this version when generating code.
        /// </remarks>
        private static readonly Version CSharpEight = new Version("8.0");

        #endregion
    }
}
